<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄杰|博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hj0913.github.io/"/>
  <updated>2019-08-14T09:13:17.393Z</updated>
  <id>https://hj0913.github.io/</id>
  
  <author>
    <name>Huang Jie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库索引总结</title>
    <link href="https://hj0913.github.io/2019/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/"/>
    <id>https://hj0913.github.io/2019/08/14/数据库索引总结/</id>
    <published>2019-08-14T00:55:40.000Z</published>
    <updated>2019-08-14T09:13:17.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一，索引的种类"><a href="#一，索引的种类" class="headerlink" title="一，索引的种类"></a>一，索引的种类</h2><h3 id="一，从数据结构角度"><a href="#一，从数据结构角度" class="headerlink" title="一，从数据结构角度"></a>一，从数据结构角度</h3><ol><li><p>B+树索引(O(log(n)))：n是记录总树，底数是树的分叉数，结果就是树的层次数,关于B+树索引，可以参考<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><ul><li>B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会<strong>破坏它的原有结构</strong>。</li><li><strong>要维持平衡树，就必须做额外的工作</strong>。正因为这些额外的工作<strong>开销</strong>，导致索引会降低增删改的速度</li></ul></li><li><p>hash索引：哈希索引就是采用一定的<strong>哈希算法</strong>，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可<strong>立刻定位到相应的位置，速度非常快</strong>。</p><p>hash索引的缺点：</p><ul><li><p>哈希索引也没办法利用索引完成<strong>排序</strong></p></li><li><p>不支持<strong>最左匹配原则</strong></p></li><li><p>在有大量重复键值情况下，哈希索引的效率也是极低的—-&gt;<strong>哈希碰撞</strong>问题。</p></li><li><p><strong>不支持范围查询</strong>，仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询</p></li><li><p>其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引</p></li><li><p>只有Memory存储引擎显示支持hash索引</p></li></ul></li><li><p>FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）</p></li><li><p>R-Tree索引（用于对GIS数据类型创建SPATIAL索引）</p></li></ol><h3 id="二，从物理存储角度"><a href="#二，从物理存储角度" class="headerlink" title="二，从物理存储角度"></a>二，从物理存储角度</h3><ol><li>聚集索引(clustered index)就是以<strong>主键</strong>创建的索引</li><li>非聚集索引(non-clustered index)就是以<strong>非主键</strong>创建的索引<ul><li>区别：<ul><li>聚集索引在叶子节点存储的是<strong>表中的数据</strong></li><li>非聚集索引在叶子节点存储的是<strong>主键和索引列</strong></li><li>使用非聚集索引查询出数据时，<strong>拿到叶子上的主键再去查到想要查找的数据</strong>。(拿到主键再查找这个过程叫做<strong>回表</strong>)</li></ul></li></ul></li></ol><h3 id="三，从逻辑角度"><a href="#三，从逻辑角度" class="headerlink" title="三，从逻辑角度"></a>三，从逻辑角度</h3><ol><li><p>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</p></li><li><p>普通索引或者单列索引</p></li><li><p>多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合；</p><ul><li>我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值</li><li>最终还是要“回表”，也就是要通过主键<strong>再</strong>查找一次。这样就会比较慢</li><li>覆盖索引就是把要<strong>查询出的列和索引是对应的</strong>，不做回表操作！</li><li>比如说：<ul><li>现在我创建了索引<code>(username,age)</code>，在查询数据的时候：<code>select username , age from user where username = &#39;Java3y&#39; and age = 20</code>。</li><li>很明显地知道，我们上边的查询是走索引的，并且，<strong>要查询出的列在叶子节点都存在</strong>！所以，就不用回表了~</li><li>所以，能使用覆盖索引就尽量使用吧~</li></ul></li></ul></li><li><p>唯一索引或者非唯一索引</p></li><li><p>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。<br>MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</p></li></ol><h3 id="索引最左匹配原则："><a href="#索引最左匹配原则：" class="headerlink" title="索引最左匹配原则："></a>索引最左匹配原则：</h3><ul><li><p>索引可以简单如一个列<code>(a)</code>，也可以复杂如多个列<code>(a, b, c, d)</code>，即<strong>联合索引</strong>。</p></li><li><p>如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否<strong>存在（相等）</strong>，遇到范围查询<code>(&gt;、&lt;、between、like</code>左匹配)等就<strong>不能进一步匹配</strong>了，后续退化为线性查找。</p></li><li><p>因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</p><p>例子：</p></li><li><p>如有索引<code>(a, b, c, d)</code>，查询条件<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，则会在每个节点依次命中a、b、c，无法命中d。(很简单：索引命中只能是<strong>相等</strong>的情况，不能是范围匹配)</p></li></ul><h3 id="索引总结"><a href="#索引总结" class="headerlink" title="索引总结"></a>索引总结</h3><p>索引在数据库中是一个<strong>非常</strong>重要的知识点！上面谈的其实就是索引<strong>最基本</strong>的东西，要创建出好的索引要顾及到很多的方面：</p><ul><li>1，<strong>最左前缀匹配原则</strong>。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询<code>（&gt;,&lt;,BETWEEN,LIKE）</code>就停止匹配。</li><li>3，尽量选择<strong>区分度高的列作为索引</strong>，区分度的公式是 <code>COUNT(DISTINCT col) / COUNT(*)</code>。表示字段不重复的比率，比率越大我们扫描的记录数就越少。</li><li>4，<strong>索引列不能参与计算，尽量保持列“干净”</strong>。比如，<code>FROM_UNIXTIME(create_time) = &#39;2016-06-06&#39;</code> 就不能使用索引，原因很简单，<strong>B+树中存储的都是数据表中的字段值</strong>，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： <code>create_time = UNIX_TIMESTAMP(&#39;2016-06-06&#39;)</code>。</li><li>5，尽可能的<strong>扩展索引</strong>，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。</li><li>6，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，<strong>MySQL只能使用一个索引</strong>，会从多个单列索引中选择一个限制最为严格的索引。</li></ul><p>参考文档：</p><p><a href="https://juejin.im/post/5b55b842f265da0f9e589e79" target="_blank" rel="noopener">数据库两大神器【索引和锁】</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&mid=2247483701&idx=1&sn=bd229dd584f51ef4fe545d44ad8cdbf9&chksm=979688c7a0e101d1b5c752094013b78f5bd50ab905257ba82149d85d35ea07aba1a15b0e52b4&mpshare=1&scene=1&srcid=0409Tn66UYWSWvqEVlOpwGtR&key=6cd553e86912686a47d76f2d900b1b5b388c90b29708f016db3a6e1bcebe032220ba63626095c4298f32cda7d0d7bd11bded2365f05c32e522584dd149b98db0bb8549ef144cdca694665d31d35cfeef&ascene=0&uin=MzAzMjU4NDM3Nw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.12.4+build(16E195)&version=12020810&nettype=WIFI&lang=zh_CN&fontScale=100&pass_ticket=YHEmqDDX8hHkj5FiSVpQvjYqIMBDHHDS2po4mfJe%2BqIXlqwJI%2Bg7aJUZq0%2BDwGJ0" target="_blank" rel="noopener">MySQL的索引</a></p><p><a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">深入浅出的理解数据库索引</a></p><p>阿里巴巴Java开发手册</p><h2 id="二，数据库引擎"><a href="#二，数据库引擎" class="headerlink" title="二，数据库引擎"></a>二，数据库引擎</h2><h3 id="一，Innodb"><a href="#一，Innodb" class="headerlink" title="一，Innodb"></a>一，Innodb</h3><p>InnoDB是事务型数据库首选引擎，支持事务安全表(ACID),支持行锁定和外键，InnoDB是默认的MySQL引擎。InnoDB主要特性有：</p><ol><li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Flib.csdn.net%2Fbase%2Foracle" target="_blank" rel="noopener"><strong>Oracle</strong></a>的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li><li>InnoDB是为处理巨<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http%3A%2F%2Flib.csdn.net%2Fbase%2Fhadoop" target="_blank" rel="noopener"><strong>大数据</strong></a>量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</li><li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li><li>InnoDB被用在众多需要高性能的大型数据库站点上</li></ol><h3 id="二，MyIASM"><a href="#二，MyIASM" class="headerlink" title="二，MyIASM"></a>二，MyIASM</h3><p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但<strong>不支持事物</strong>。MyISAM主要特性有：</p><ol><li><p>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</p></li><li><p>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成</p></li><li><p>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</p></li><li><p>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</p></li><li><p>BLOB和TEXT列可以被索引</p></li><li><p>NULL被允许在索引的列中，这个值占每个键的0~1个字节</p></li><li><p>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</p></li><li><p>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</p></li><li><p>可以把数据文件和索引文件放在不同目录</p></li><li><p>每个字符列可以有不同的字符集</p></li><li><p>有VARCHAR的表可以固定或动态记录长度</p></li><li><p>VARCHAR和CHAR列可以多达64KB</p></li></ol><p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p><h3 id="三，MEMORY"><a href="#三，MEMORY" class="headerlink" title="三，MEMORY"></a>三，MEMORY</h3><ol><li><p>MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度</p></li><li><p>MEMORY存储引擎执行HASH和BTREE缩影</p></li><li><p>可以在一个MEMORY表中有非唯一键值</p></li><li><p>MEMORY表使用一个固定的记录长度格式</p></li><li><p>MEMORY不支持BLOB或TEXT列</p></li><li><p>MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引</p></li><li><p>MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）</p></li><li><p>MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享</p></li><li><p>当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）</p></li></ol><h3 id="四，Achive"><a href="#四，Achive" class="headerlink" title="四，Achive"></a>四，Achive</h3><table><thead><tr><th align="center">功能</th><th align="center">MYISAM</th><th align="center">Memory</th><th align="center">InnoDB</th><th align="center">Achive</th></tr></thead><tbody><tr><td align="center">存储限制</td><td align="center">256TB</td><td align="center">RAM</td><td align="center">64TB</td><td align="center">None</td></tr><tr><td align="center">支持事务</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">支持全文索引</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">支持数索引</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">支持哈希索引</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">支持数据缓存</td><td align="center">no</td><td align="center">N/A</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">支持外键</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td></tr></tbody></table><h2 id="三，数据库事务"><a href="#三，数据库事务" class="headerlink" title="三，数据库事务"></a>三，数据库事务</h2><h2 id="四，数据库锁"><a href="#四，数据库锁" class="headerlink" title="四，数据库锁"></a>四，数据库锁</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一，索引的种类&quot;&gt;&lt;a href=&quot;#一，索引的种类&quot; class=&quot;headerlink&quot; title=&quot;一，索引的种类&quot;&gt;&lt;/a&gt;一，索引的种类&lt;/h2&gt;&lt;h3 id=&quot;一，从数据结构角度&quot;&gt;&lt;a href=&quot;#一，从数据结构角度&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://hj0913.github.io/tags/SQL/"/>
    
      <category term="JAVA面试" scheme="https://hj0913.github.io/tags/JAVA%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化</title>
    <link href="https://hj0913.github.io/2019/08/13/SQL%E4%BC%98%E5%8C%96/"/>
    <id>https://hj0913.github.io/2019/08/13/SQL优化/</id>
    <published>2019-08-13T11:04:00.000Z</published>
    <updated>2019-08-14T00:54:16.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL优化方案"><a href="#SQL优化方案" class="headerlink" title="SQL优化方案"></a>SQL优化方案</h2><h3 id="一，SQL语句性能优化"><a href="#一，SQL语句性能优化" class="headerlink" title="一，SQL语句性能优化"></a>一，SQL语句性能优化</h3><ol><li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by 涉及的列上建立索引</p></li><li><p>应尽量避免在 where 子句中对字段进行 null 值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默 认值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符， MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p></li><li><p>应尽量避免在 where 子句中使用 or 来连接条件， 否则将导致引擎放弃使用索引而进行全表扫描， 可以 使用UNION合并查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>可以这样查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p> 对于连续的数值，能用 between 就不要用 in 了：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>下面的查询也将导致全表扫描：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &apos;%c%&apos;;</span><br></pre></td></tr></table></figure><p> 若要提高效率，可以考虑全文检索。</p></li><li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span>;</span><br></pre></td></tr></table></figure><p>可以改为强制查询使用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span>;</span><br></pre></td></tr></table></figure></li><li><p>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>可以这样查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'abc'</span>;<span class="comment">#name 以 abc 开头的 id</span></span><br></pre></td></tr></table></figure><p>应改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</p></li><li><p><strong>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。</strong></p></li><li><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> <span class="comment">#t from t where 1=0;</span></span><br></pre></td></tr></table></figure><p> 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="comment">#t(…);</span></span><br></pre></td></tr></table></figure></li><li><p>很多时候用 exists 代替 in 是一个好的选择：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> b);</span><br></pre></td></tr></table></figure><p> 用下面的语句替换：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">num</span> <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> <span class="keyword">num</span>=a.num);</span><br></pre></td></tr></table></figure></li><li><p>并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时， SQL 查询可能不会去利用索引，如一表中有字段 sex,male、female 几乎各一半，那么即使在 sex 上建 了索引也对查询效率起不了作用。</p></li><li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p></li><li><p>应尽可能的避免更新 clustered 索引数据列， 因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p></li><li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言 只需要比较一次就够了。</p></li><li><p>尽可能的使用 varchar/nvarchar 代替 char/nchar , 因为首先变长字段存储空间小， 可以节省存储空间， 其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p></li><li><p>任何地方都不要使用 select * from t ,用具体的字段列表代替“*”,不要返回用不到的任何字段。</p></li><li><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限(只有主键索引)。</p></li><li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p></li><li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用 表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p></li><li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table,避免造成大量 log ,以提高速度;如果数据量不大，为了缓和系统表的资源，应先 create table,然后 insert。</p></li><li><p>如果使用到了临时表， 在存储过程的最后务必将所有的临时表显式删除， 先 truncate table ,然后 drop table ,这样可以避免系统表的较长时间锁定。</p></li><li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。</p></li><li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更 有效。</p></li><li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p></li><li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ,在结束时设置 SET NOCOUNT OFF .无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p></li><li><p>尽量避免大事务操作，提高系统并发能力。 sql 优化方法使用索引来更快地遍历表。 缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理上随机存放在数据页上。合理的索引设计要建立在对各种查询的分析和预测上。一般来说：</p><ul><li>有大量重复值、且经常有范围查询( &gt; ,&lt; ,&gt; =,&lt; =)和 order by、group by 发生的列，可考虑建立集群索引;</li><li>经常同时存取多列，且每列都含有重复值可考虑建立组合索引;</li><li>组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但 不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就 要做相应的更新工作。</li></ul></li><li><p>定期分析表和检查表</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">分析表的语法：ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tb1_name[, tbl_name]...</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p> 以上语句用于分析和存储表的关键字分布，分析的结果将可以使得系统得到准确的统计信息，使得SQL能够生成正确的执行计划。如果用户感觉实际执行计划并不是预期的执行计划，执行一次分析表可能会解决问题。在分析期间，使用一个读取锁定对表进行锁定。这对于MyISAM，DBD和InnoDB表有作用。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如分析一个数据表：<span class="keyword">analyze</span> <span class="keyword">table</span> table_name</span><br><span class="line"></span><br><span class="line">检查表的语法：<span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tb1_name[,tbl_name]...[<span class="keyword">option</span>]...option = &#123;<span class="keyword">QUICK</span> | <span class="keyword">FAST</span> | <span class="keyword">MEDIUM</span> | <span class="keyword">EXTENDED</span> | <span class="keyword">CHANGED</span>&#125;</span><br></pre></td></tr></table></figure><p> 检查表的作用是检查一个或多个表是否有错误，CHECK TABLE 对MyISAM 和 InnoDB表有作用，对于MyISAM表，关键字统计数据被更新</p></li><li><p>定期优化表。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化表的语法：<span class="keyword">OPTIMIZE</span> [<span class="keyword">LOCAL</span> | <span class="keyword">NO_WRITE_TO_BINLOG</span>] <span class="keyword">TABLE</span> tb1_name [,tbl_name]...</span><br></pre></td></tr></table></figure><p> 如果删除了表的一大部分，或者如果已经对含有可变长度行的表(含有 VARCHAR、BLOB或TEXT列的表)进行更多更改，则应使用OPTIMIZE TABLE命令来进行表优化。这个命令可以将表中的空间碎片进行合并，并且可以消除由于删除或者更新造成的空间浪费，但OPTIMIZE TABLE 命令只对MyISAM、 BDB 和InnoDB表起作用。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如： <span class="keyword">optimize</span> <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure><blockquote><p>注意： analyze、check、optimize执行期间将对表进行锁定，因此一定注意要在MySQL数据库不繁忙的时候执行相关的操作。</p></blockquote></li></ol><h3 id="二，其他优化"><a href="#二，其他优化" class="headerlink" title="二，其他优化"></a>二，其他优化</h3><ol><li><p>在海量查询时尽量少用格式转换。</p></li><li><p>ORDER BY 和 GROPU BY:使用 ORDER BY 和 GROUP BY 短语，任何一种索引都有助于 SELECT 的性能提高。</p></li><li><p>任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移 至等号右边。</p></li><li><p>IN、OR 子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子 句中应该包含索引。</p></li><li><p>只要能满足你的需求，应尽可能使用更小的数据类型：例如使用 MEDIUMINT 代替 INT</p></li><li><p>尽量把所有的列设置为 NOT NULL,如果你要保存 NULL,手动去设置它，而不是把它设为默认值。</p></li><li><p>尽量少用TEXT、BLOB 类型</p></li><li><p>如果你的数据只有你所知的少量的几个。最好使用 ENUM 类型</p></li><li><p>正如 graymice 所讲的那样，建立索引。</p></li><li><p>合理用运分表与分区表提高数据存放和提取速度。</p></li></ol><p><strong>转自链接</strong>：<a href="https://juejin.im/post/5aa7703c6fb9a028c8128739" target="_blank" rel="noopener">https://juejin.im/post/5aa7703c6fb9a028c8128739</a></p><p><strong>转自来源</strong>：掘金</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL优化方案&quot;&gt;&lt;a href=&quot;#SQL优化方案&quot; class=&quot;headerlink&quot; title=&quot;SQL优化方案&quot;&gt;&lt;/a&gt;SQL优化方案&lt;/h2&gt;&lt;h3 id=&quot;一，SQL语句性能优化&quot;&gt;&lt;a href=&quot;#一，SQL语句性能优化&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="SQL" scheme="https://hj0913.github.io/tags/SQL/"/>
    
      <category term="JAVA面试" scheme="https://hj0913.github.io/tags/JAVA%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>k8s二进制部署(HTTPS+RBAC)</title>
    <link href="https://hj0913.github.io/2019/08/06/k8s%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%83%A8%E7%BD%B2-HTTPS-RBAC/"/>
    <id>https://hj0913.github.io/2019/08/06/k8s二进制部署-HTTPS-RBAC/</id>
    <published>2019-08-06T00:47:10.000Z</published>
    <updated>2019-08-06T01:24:47.146Z</updated>
    
    <content type="html"><![CDATA[<h3 id="k8s二进制部署-HTTPS-RBAC"><a href="#k8s二进制部署-HTTPS-RBAC" class="headerlink" title="k8s二进制部署(HTTPS+RBAC)"></a>k8s二进制部署(HTTPS+RBAC)</h3><h4 id="官方提供的几种Kubernetes部署方式"><a href="#官方提供的几种Kubernetes部署方式" class="headerlink" title="官方提供的几种Kubernetes部署方式"></a>官方提供的几种Kubernetes部署方式</h4><ul><li><p><strong>minikube</strong></p><p>​        Minikube是一个工具，可以在本地快速运行一个单点的Kubernetes，尝试Kubernetes或日常开发的用户使用。不能用于生产环境。</p><p>官方地址：<a href="https://kubernetes.io/docs/setup/minikube/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/minikube/</a></p></li><li><p><strong>kubeadm</strong></p><p>​        Kubeadm也是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。</p><p>官方地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p></li><li><p><strong>二进制包</strong></p><p>​        从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。<br><strong>小结：</strong></p><p>​        生产环境中部署Kubernetes集群，只有Kubeadm和二进制包可选，Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。我们这里使用二进制包部署Kubernetes集群，我也是推荐大家使用这种方式，虽然手动部署麻烦点，但学习很多工作原理，更有利于后期维护。</p></li></ul><p>参考地址：<a href="https://blog.51cto.com/lizhenliang/2325770" target="_blank" rel="noopener">李振良博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;k8s二进制部署-HTTPS-RBAC&quot;&gt;&lt;a href=&quot;#k8s二进制部署-HTTPS-RBAC&quot; class=&quot;headerlink&quot; title=&quot;k8s二进制部署(HTTPS+RBAC)&quot;&gt;&lt;/a&gt;k8s二进制部署(HTTPS+RBAC)&lt;/h3&gt;&lt;h4
      
    
    </summary>
    
    
      <category term="docker" scheme="https://hj0913.github.io/tags/docker/"/>
    
      <category term="k8s" scheme="https://hj0913.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>JAVA集合总结</title>
    <link href="https://hj0913.github.io/2019/08/05/JAVA%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93/"/>
    <id>https://hj0913.github.io/2019/08/05/JAVA集合总结/</id>
    <published>2019-08-05T02:20:30.000Z</published>
    <updated>2019-08-06T06:42:54.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA集合总结"><a href="#JAVA集合总结" class="headerlink" title="JAVA集合总结"></a>JAVA集合总结</h3><h4 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h4><ul><li><p>概述</p><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，<strong>并允许使用 null 值和 null 键</strong>。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA集合总结&quot;&gt;&lt;a href=&quot;#JAVA集合总结&quot; class=&quot;headerlink&quot; title=&quot;JAVA集合总结&quot;&gt;&lt;/a&gt;JAVA集合总结&lt;/h3&gt;&lt;h4 id=&quot;HashMap的实现原理&quot;&gt;&lt;a href=&quot;#HashMap的实现原理&quot; cla
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://hj0913.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务探索</title>
    <link href="https://hj0913.github.io/2019/07/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A2%E7%B4%A2/"/>
    <id>https://hj0913.github.io/2019/07/24/分布式事务探索/</id>
    <published>2019-07-24T09:43:57.000Z</published>
    <updated>2019-07-26T01:03:29.179Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知道你是否遇到过这样的情况，去小卖铺买东西，付了钱，但是店主因为处理了一些其他事，居然忘记你付了钱，又叫你重新付。又或者在网上购物明明已经扣款，但是却告诉我没有发生交易。这一系列情况都是因为没有事务导致的。这说明了事务在生活中的一些重要性。有了事务，你去小卖铺买东西，那就是一手交钱一手交货。有了事务，你去网上购物，扣款即产生订单交易。</p><h3 id="事务的具体定义"><a href="#事务的具体定义" class="headerlink" title="事务的具体定义"></a>事务的具体定义</h3><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。</p><h3 id="数据库本地事务"><a href="#数据库本地事务" class="headerlink" title="数据库本地事务"></a>数据库本地事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>说到数据库事务就不得不说，数据库事务中的四大特性，ACID:</p><ul><li>A:原子性(Atomicity)<br>一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>就像你买东西要么交钱收货一起都执行，要么要是发不出货，就退钱。</li><li>C:一致性(Consistency)<br>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</li><li>I:隔离性(Isolation)<br>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。<br>打个比方，你买东西这个事情，是不影响其他人的。</li><li>D:持久性(Durability)<br>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。<br>打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。<h4 id="InnoDB实现原理"><a href="#InnoDB实现原理" class="headerlink" title="InnoDB实现原理"></a>InnoDB实现原理</h4>InnoDB是mysql的一个存储引擎，大部分人对mysql都比较熟悉，这里简单介绍一下数据库事务实现的一些基本原理，在本地事务中，服务和资源在事务的包裹下可以看做是一体的:<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/164d65a2768cd3d6.JPG" alt="事务"><br>我们的本地事务由资源管理器进行管理:<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard.png" alt="InnoDB"><br>而事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 和Undo Log相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。 对具体实现过程有兴趣的同学可以去自行搜索扩展。<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h4>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<h4 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h4>从上面本地事务来看，我们可以看为两块，一个是service产生多个节点，另一个是resource产生多个节点。<h5 id="service多个节点"><a href="#service多个节点" class="headerlink" title="service多个节点"></a>service多个节点</h5>随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard1.png" alt="service多个节点"><br>这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。<h5 id="resource多个节点"><a href="#resource多个节点" class="headerlink" title="resource多个节点"></a>resource多个节点</h5>同样的，互联网发展得太快了，我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard2.png" alt="resource多个节点"><h4 id="分布式事务的基础"><a href="#分布式事务的基础" class="headerlink" title="分布式事务的基础"></a>分布式事务的基础</h4>从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:<h5 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h5>从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:<h3 id="CAP-1"><a href="#CAP-1" class="headerlink" title="CAP"></a>CAP</h3>CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。</li><li>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</li><li>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。</li><li>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。<br>熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。<br>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。<br>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。<br>顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。<h5 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h5>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展</li></ul><ol><li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li><li>软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。</li><li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。<br>BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。<h4 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h4>有了上面的理论基础后，这里介绍开始介绍几种常见的分布式事务的解决方案。<h5 id="是否真的要分布式事务"><a href="#是否真的要分布式事务" class="headerlink" title="是否真的要分布式事务"></a>是否真的要分布式事务</h5>在说方案之前，首先你一定要明确你是否真的需要分布式事务？<br>上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪，而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。<br>如果你确定需要引入分布式事务可以看看下面几种常见的方案。<h5 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h5>说到2PC就不得不聊数据库分布式事务中的 XA Transactions。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard3.png" alt="2PC"><br>在XA协议中分为两阶段:<br>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.<br>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。<br>优点： 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。<br>缺点:</li></ol><ul><li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li><li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li><li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。<br>总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。<h5 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h5>关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点: 1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard4.png" alt="TCC"><br>对于TCC的解释:</li><li>Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</li><li>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li><li>Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。<br>举个简单的例子如果你用100元买了一瓶水， Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。<br>如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。<br>如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)<br>对于TCC来说适合一些:</li><li>强隔离性，严格一致性要求的活动业务。</li><li>执行时间较短的业务<br>实现参考:ByteTCC:<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fliuyangming%2FByteTCC%2F" target="_blank" rel="noopener">github.com/liuyangming…</a><h5 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h5>本地消息表这个方案最初是ebay提出的 ebay的完整方案<a href="https://queue.acm.org/detail.cfm?id=1394128。" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128。</a><br>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard5.png" alt="本地消息表"><br>对于本地消息队列来说核心是把大事务转变为小事务。还是举上面用100元去买一瓶水的例子。</li></ul><p>1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。<br>2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。<br>3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。<br>4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。<br>本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。</p><h5 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h5><p>在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，下面简单介绍一下MQ事务，如果想对其详细了解可以参考:<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F453c6e7ff81c%E3%80%82" target="_blank" rel="noopener">www.jianshu.com/p/453c6e7ff…</a><br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard6.png" alt="MQ事务1"><br>基本流程如下: 第一阶段Prepared消息，会拿到消息的地址。<br>第二阶段执行本地事务。<br>第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。<br>如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard7.png" alt="MQ事务2"><br>如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失</p><h5 id="Saga事务"><a href="#Saga事务" class="headerlink" title="Saga事务"></a>Saga事务</h5><p>Saga是30年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。 Saga的组成：<br>每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。 可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。<br>Saga的执行顺序有两种：<br>T1, T2, T3, …, Tn<br>T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n Saga定义了两种恢复策略：<br>向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。 向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。<br>这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。<br>还是拿100元买一瓶水的例子来说，这里定义<br>T1=扣100元 T2=给用户加一瓶水 T3=减库存一瓶水<br>C1=加100元 C2=给用户减一瓶水 C3=给库存加一瓶水<br>我们一次进行T1,T2，T3如果发生问题，就执行发生问题的C操作的反向。 上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题<br>可以看见saga模式没有隔离性的影响还是较大，可以参照华为的解决方案:从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。<br>具体实例:可以参考华为的servicecomb</p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>还是那句话，能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。上面对解决方案只是一些简单介绍，如果真正的想要落地，其实每种方案需要思考的地方都非常多，复杂度都比较大，所以最后再次提醒一定要判断好是否使用分布式事务。最后在总结一些问题,大家可以下来自己从文章找寻答案:</p><ol><li>ACID和CAP的 CA是一样的吗？</li><li>分布式事务常用的解决方案的优缺点是什么？适用于什么场景？</li><li>分布式事务出现的原因？用来解决什么痛点？<br>转自作者：咖啡拿铁<br>转自链接：<a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b" target="_blank" rel="noopener">https://juejin.im/post/5b5a0bf9f265da0f6523913b</a><br>转自来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;不知道你是否遇到过这样的情况，去小卖铺买东西，付了钱，但是店主因为处理了一些其他事，居然忘记你付了钱，又叫你重新付。又或者在网上购物明明已经
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://hj0913.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="https://hj0913.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>docker-swarm模式下Springcloud容器相互注册</title>
    <link href="https://hj0913.github.io/2019/07/24/docker-swarm%E6%A8%A1%E5%BC%8F%E4%B8%8BSpringcloud%E5%AE%B9%E5%99%A8%E7%9B%B8%E4%BA%92%E6%B3%A8%E5%86%8C/"/>
    <id>https://hj0913.github.io/2019/07/24/docker-swarm模式下Springcloud容器相互注册/</id>
    <published>2019-07-24T08:04:10.000Z</published>
    <updated>2019-07-24T08:04:10.906Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>修改docker日志目录</title>
    <link href="https://hj0913.github.io/2019/07/23/%E4%BF%AE%E6%94%B9docker%E6%97%A5%E5%BF%97%E7%9B%AE%E5%BD%95/"/>
    <id>https://hj0913.github.io/2019/07/23/修改docker日志目录/</id>
    <published>2019-07-23T04:35:54.000Z</published>
    <updated>2019-07-24T08:47:47.817Z</updated>
    
    <content type="html"><![CDATA[<p>默认安装完成docker后docker的所有images及相关信息存储位置为：/var/lib/docker</p><p>镜像默认路径: /var/lib/docker/containers/</p><p>而通常我们的系统盘挂载一般不会很大，所以需要将其移到其他分区，我们可以采用</p><h3 id="一，软链接的方式"><a href="#一，软链接的方式" class="headerlink" title="一，软链接的方式"></a>一，软链接的方式</h3><ol><li><p>首先暂停docker服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker.service</span><br></pre></td></tr></table></figure></li><li><p>将文件移到指定目录</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib</span><br><span class="line"><span class="comment"># 文件复制</span></span><br><span class="line">mv docker/* /home/docker-log</span><br><span class="line"><span class="comment"># 删除原来/var/lib下的docker文件夹</span></span><br><span class="line">rm -rf docker</span><br><span class="line"><span class="comment"># 进入/dome/docker-log创建软连接</span></span><br><span class="line">ln -s /home/docker-log /var/lib/docker</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service</span><br><span class="line">docker info <span class="comment"># 查看是否成功</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二，修改镜像和容器的存放路径"><a href="#二，修改镜像和容器的存放路径" class="headerlink" title="二，修改镜像和容器的存放路径"></a>二，修改镜像和容器的存放路径</h3><p>指定镜像和容器存放路径的参数是–graph=/var/lib/docker，我们只需要修改配置文件指定启动参数即可。</p><p>Docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致，在 Ubuntu 中的位置是：/etc/default/docker，在 CentOS 中的位置是：/etc/sysconfig/docker。</p><p>如果是 CentOS6 则添加下面这行：</p><p>OPTIONS=–graph=”/root/data/docker” –selinux-enabled -H fd://</p><p>如果是 Ubuntu 则添加下面这行（因为 Ubuntu 默认没开启 selinux）：</p><p>OPTIONS=–graph=”/root/data/docker” -H fd://# 或者DOCKER_OPTS=”-g /root/data/docker”</p><p>最后重新启动，Docker 的路径就改成 /root/data/docker 了。</p><p>centos7下，也可以</p><p>修改docker.service文件，使用-g参数指定存储位置</p><p>vi /usr/lib/systemd/system/docker.service  </p><p>ExecStart=/usr/bin/dockerd –graph /new-path/docker </p><p> // reload配置文件 </p><p>systemctl daemon-reload </p><p> // 重启docker </p><p>systemctl restart docker.service</p><p><font color="red"><strong>如果docker是1.12或以上的版本，可以修改（或新建）daemon.json文件。修改后会立即生效，不需重启docker服务。</strong></font></p><p>vim /etc/docker/daemon.json </p><p>{“registry-mirrors”: [“<a href="http://7e61f7f9.m.daocloud.io&quot;],&quot;graph&quot;" target="_blank" rel="noopener">http://7e61f7f9.m.daocloud.io&quot;],&quot;graph&quot;</a>: “/new-path/docker”}</p><h3 id="三，system下创建配置文件"><a href="#三，system下创建配置文件" class="headerlink" title="三，system下创建配置文件"></a>三，system下创建配置文件</h3><p>在/etc/systemd/system/docker.service.d 目录下创建一个Drop-In文件“docker.conf”，默认 docker.service.d 文件夹不存在。所以你必须先创建它。</p><p>创建Drop-In 文件的原因，是我们希望Docker 服务，使用docker.conf文件中提到的特定参数，将默认服务所使用的位于/lib/systemd/system/docker.service文件中的参数进行覆盖。如果你想深入了解Drop-In，请阅读<a href="https://goo.gl/7KzBGT" target="_blank" rel="noopener">system.unit</a>文档</p><p><strong>定义新的存储位置</strong>现在打开docker.conf增加如下内容：</p><p># sudo vi /etc/systemd/system/docker.service.d/docker.conf </p><p>[Service] </p><p>ExecStart= </p><p>ExecStart=/usr/bin/dockerd –graph=”/mnt/new_volume” –storage-driver=devicemapper</p><p>保存并退出VI编辑器，/mnt/new_volume 是新的存储位置，而devicemapper是当前docker所使用的存储驱动。如果你的存储驱动有所不同，请输入之前第一步查看并记下的值。Docker<a href="https://goo.gl/VnHP61" target="_blank" rel="noopener">官方文档</a>中提供了更多有关各种存储驱动器的信息。现在，你可以重新加载服务守护程序，并启动Docker服务了。这将改变新的镜像和容器的存储位置。</p><p># sudo systemctl daemon-reload </p><p># sudo systemctl start docker</p><p>为了确认一切顺利，运行 # docker info 命令检查Docker 的根目录.它将被更改为/mnt/new_volume</p><h3 id="四，使用docker-storage-set（docker1-12）命令进行配置"><a href="#四，使用docker-storage-set（docker1-12）命令进行配置" class="headerlink" title="四，使用docker-storage-set（docker1.12）命令进行配置"></a>四，使用docker-storage-set（docker1.12）命令进行配置</h3><p>配置文件位置：<strong>/usr/lib/docker-storage-setup/docker-storage-setup</strong>或者<strong>/etc/sysconfig/docker-storage-setup、/etc/sysconfig/docker-storage</strong></p><p>vim /etc/sysconfig/docker-storage</p><p># This file may be automatically generated by an installation program.</p><p># Please DO NOT edit this file directly. Instead edit</p><p># /etc/sysconfig/docker-storage-setup and/or refer to</p><p># “man docker-storage-setup”.</p><p># By default, Docker uses a loopback-mounted sparse file in</p><p># /var/lib/docker.  The loopback makes it slower, and there are some</p><p># restrictive defaults, such as 100GB max storage.</p><p>DOCKER_STORAGE_OPTIONS=–graph=”要保存的路径”</p><p>或者</p><p>DEVS=/dev/vdb</p><p>DATA_SIZE=800GB（更改docker默认存储大小）</p><p><a href="https://blog.51cto.com/forangela/1949947" target="_blank" rel="noopener">参考连接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;默认安装完成docker后docker的所有images及相关信息存储位置为：/var/lib/docker&lt;/p&gt;
&lt;p&gt;镜像默认路径: /var/lib/docker/containers/&lt;/p&gt;
&lt;p&gt;而通常我们的系统盘挂载一般不会很大，所以需要将其移到其他分区，我
      
    
    </summary>
    
    
      <category term="docker" scheme="https://hj0913.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>jenkins安装(yum源安装)</title>
    <link href="https://hj0913.github.io/2019/07/18/jenkins%E5%AE%89%E8%A3%85-yum%E6%BA%90%E5%AE%89%E8%A3%85/"/>
    <id>https://hj0913.github.io/2019/07/18/jenkins安装-yum源安装/</id>
    <published>2019-07-18T07:40:36.000Z</published>
    <updated>2019-07-25T09:06:41.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一，前沿"><a href="#一，前沿" class="headerlink" title="一，前沿"></a>一，前沿</h3><ol><li><p>Jenkins是什么？<br>Jenkins是一个开源的支持自动化构建，部署等任务的平台。基本上可以说是持续集成(CI),持续发布(CD)不可缺的工具。Jenkins的<a href="https;//jenkins.io">官方地址</a></p></li><li><p>本篇环境信息</p><table><thead><tr><th>工具/环境</th><th>版本</th></tr></thead><tbody><tr><td>Linux Server</td><td>CentOS 7</td></tr><tr><td>Jenkins</td><td>2.121.2</td></tr><tr><td>JDK</td><td>1.8.0_181</td></tr></tbody></table></li><li><p>准备工作<br>安装jdk,安装maven</p><h3 id="二，安装Jenkins"><a href="#二，安装Jenkins" class="headerlink" title="二，安装Jenkins"></a>二，安装Jenkins</h3></li><li><p>yum源的安装</p><ul><li><p>yum源导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加Yum源</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"><span class="comment">#导入密钥</span></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y jenkins</span><br></pre></td></tr></table></figure></li></ul></li><li><p>开放端口<br>Jenkins站点的默认监听端口是8080</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li><li><p>配置Java可选路径<br> 因为Jenkins默认的java可选路径不包含我们部署的jdk路径，所以这里要配置一下，不然Jenkins服务会启动失败</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改jenkins启动脚本</span></span><br><span class="line">sudo vi /etc/init.d/jenkins</span><br><span class="line"><span class="comment">#修改candidates增加java可选路径：/usr/java/jdk1.8.0_181/bin/java</span></span><br><span class="line">candidates=<span class="string">"</span></span><br><span class="line"><span class="string">/etc/alternatives/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/java-1.8.0/bin/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/jre-1.8.0/bin/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/java-1.7.0/bin/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/jre-1.7.0/bin/java</span></span><br><span class="line"><span class="string">/usr/bin/java</span></span><br><span class="line"><span class="string">/usr/java/jdk1.8.0_181/bin/java</span></span><br></pre></td></tr></table></figure></li><li><p>启动Jenkins并设置Jenkins开机启动</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重载服务（由于前面修改了Jenkins启动脚本）</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="comment">#启动Jenkins服务</span></span><br><span class="line">sudo systemctl start jenkins</span><br><span class="line"><span class="comment">#将Jenkins服务设置为开机启动</span></span><br><span class="line"><span class="comment">#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令</span></span><br><span class="line">sudo /sbin/chkconfig jenkins on</span><br></pre></td></tr></table></figure><p> 浏览器输入 http://<ip address>:8080 访问Jenkins</ip></p><h3 id="三，Jenkins初始化"><a href="#三，Jenkins初始化" class="headerlink" title="三，Jenkins初始化"></a>三，Jenkins初始化</h3></li><li><p>解锁Jenkins<br> 查询root账号默认密码</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><p> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkinsstart.png" alt="jenkins初始化"></p></li><li><p>选择插件<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins-getting-started-plugin-select.png-kblb.png" alt="jenkins选择插件"><br> 可以选择安装推荐的插件，也可以选择自定义的插件安装，其中这里我选择了第二种。<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-plugin-init.png-kblb.png" alt="jenkins初始化安装插件"></p></li><li><p>添加管理员<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-admin-add.png-kblb.png" alt="创建用户"></p></li><li><p>配置Jenkins URL<br>如果由域名的话可以填入域名，之后也可以修改；在系统管理=&gt;系统设置 <strong>Jenkins Location</strong>中设置<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-config-url.png-kblb.png" alt="配置URL"></p></li><li><p>开始使用Jenkins<br>配置完Jenkins URL之后就完成了整个Jenkins配置引导<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-done.png-kblb.png" alt="开始Jenkins"></p></li><li><p>点击“开始使用Jenkins”就会进入Jenkins主页<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-home.png-kblb.png" alt="Jenkins的主页"></p></li></ol><h3 id="四，Jenkins与git-SSH配置"><a href="#四，Jenkins与git-SSH配置" class="headerlink" title="四，Jenkins与git SSH配置"></a>四，Jenkins与git SSH配置</h3><ol><li><p>首先在jenkins服务器上安装相对应的git工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure></li><li><p>安装好git服务器，可以用gogs，GitLab或者直接使用github，gitee等仓库</p></li><li><p>在Jenkins服务器配置相对应的.ssh目录下配置config</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host git.***.com(你设置的jenkins能访问到的git域名)</span><br><span class="line">    HostName git.***.com</span><br><span class="line">    Port 10022(开放的git服务ssh端口)</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa(设置的公钥与私钥对应)</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>在git服务上进行相对应的ssh配置将jenkins生成的id_rsa.pub文件</p></li><li><p>这样配置你的jenkins服务器上应该能够clone相关的代码。如果jenkins服务与git服务放在一台服务上jenkins的web服务应该能拉取相关的代码，如果2台分开部署如何配置呢？</p></li><li><p>在jenkins的安装目录下进行ssh配置在/var/lib/jenkins创建相关的.ssh文件，设置相关的config以及私钥</p></li><li><p>在jenkins的web页面进行相关的配置将相对应的配置创建相关的密钥对应</p></li></ol><h3 id="五，Jenkins中JAVA-MAVEN配置"><a href="#五，Jenkins中JAVA-MAVEN配置" class="headerlink" title="五，Jenkins中JAVA,MAVEN配置"></a>五，Jenkins中JAVA,MAVEN配置</h3><ol><li>在jenkins服务器中安装相对应的JAVA环境，然后再系统管理中全局环境变量设置相对应的JAVA_HOME的环境</li><li>maven配置，安装相关的maven插件Pipeline Maven Integration，配置相关的.m2文件</li></ol><h3 id="六，在Jenkins中配置nodejs"><a href="#六，在Jenkins中配置nodejs" class="headerlink" title="六，在Jenkins中配置nodejs"></a>六，在Jenkins中配置nodejs</h3><ol><li><p>在centos中安装nodejs</p><ul><li><p>新建目录/opt/mnt</p></li><li><p>选择你相应的版本<a href="https://nodejs.org/zh-cn/download/releases/" target="_blank" rel="noopener">官网下载对应的版本</a></p></li><li><p>下载nodejs</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/download/release/v8.12.0/node-v8.12.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxcf -C node-v8.12.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>进入解压目录下的bin目录,执行ls命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv node-v8.12.0-linux-x64 node</span><br><span class="line"><span class="built_in">cd</span> node/bin &amp;&amp; ls</span><br></pre></td></tr></table></figure></li></ul><pre><code>有node和npm测试<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node -v</span><br></pre></td></tr></table></figure>显示版本号即代表成功</code></pre><ul><li><p>现在 <code>node</code> 和 <code>npm</code> 还不能全局使用，做个链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/mnt/node/bin/node /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line">  ln -s /opt/mnt/node/bin/npm /usr/<span class="built_in">local</span>/bin/npm</span><br></pre></td></tr></table></figure></li></ul><pre><code>至此node就安装成功了</code></pre><ol start="2"><li><p>jenkins中配置nodejs</p><p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/1563848937513.png" alt="1563848937513"></p></li><li><p>全局安装相应的angular的框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli@7.3.9</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>修改npm的淘宝镜像，在/var/lib/jenkins的目录下创建相关</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo su -s /bin/bash jenkins <span class="comment">#登录jenkins</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/jenkins</span><br><span class="line">touch .npmrc</span><br><span class="line">vi .npmrc</span><br><span class="line">registry=https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure></li></ol><h3 id="七，jenkins修改用户运行"><a href="#七，jenkins修改用户运行" class="headerlink" title="七，jenkins修改用户运行"></a>七，jenkins修改用户运行</h3><ol><li><p>解决登录jenkins的问题，由于jenkins在运行时可以选择用户进行运行；</p><ul><li><p>打开Jenkins配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure><p>找到如下行：</p><p>将原来的Jenkins用户修改为root用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JENKINS_USER=&quot;root&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>修改Jenkins相关文件夹用户权限</p><p>更改jenkins三个文件夹的用户所属用户组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown -R root:root /var/lib/jenkins   jenkins的home目录</span><br><span class="line">chown -R root:root /var/cache/jenkins jenkins的缓存目录</span><br><span class="line">chown -R root:root /var/<span class="built_in">log</span>/jenkins   jenkins的日志目录</span><br></pre></td></tr></table></figure></li><li><p>重启jenkins</p><p>重启jenkins服务并检查运行Jenkins的用户是否已经切换为root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart jenkins</span><br><span class="line">ps -ef | grep jenkins</span><br></pre></td></tr></table></figure><p>若显示为root用户，则表示修改完成</p></li></ul><h3 id="八，报错解决"><a href="#八，报错解决" class="headerlink" title="八，报错解决"></a>八，报错解决</h3><ol><li><p>jenkins登录不了Harbor问题</p><p> 错误内容：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.34/version: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure><p> 解决方案：</p><ul><li><p>优先参考官方<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">Manage Docker as a non-root user</a></p></li><li><p>关闭虚拟机的selinux（可能有用）。参考<a href="http://blog.51cto.com/bguncle/957315" target="_blank" rel="noopener">查看 SELinux状态及关闭SELinux</a></p></li><li><p>在虚拟机中修改<code>/var/run/docker.sock</code>的权限。（很危险！！！）(不推荐)</p><p>终极解决方案：</p><p>错误原因是，在push之前，需要使用docker login命令完成登录</p><p>但是Jenkins job的命令是以伪用户jenkins的名义执行的，因此无法直接在jenkins账户完成登录，那么如何解决呢？</p></li><li><p>使用root账户完成登录</p></li><li><p>将/root/目录下的.docker目录复制到/var/lib/jenkins jenkins的家目录</p></li><li><p>修改文件夹权限chown -R jenkins:jenkins .docker</p><p>原理是：登录成功后会在.docker中生成一个config.json文件，里面保存了认证的信息，以后每次执行docker pull/push时，都会通过检测该文件确定用户是否已完成认证。</p><p><a href="https://blog.csdn.net/mydeman/article/details/79042848" target="_blank" rel="noopener">参考文档1</a></p><p><a href="https://my.oschina.net/raindroid/blog/1579639" target="_blank" rel="noopener">参考文档2</a></p></li></ul></li><li><p>切换jenkins用户登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -s /bin/bash jenkins</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>解决jenkins拉取不了私服代码的问题<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/clipboard_20190723100820.png" alt="1563847680915"></p><ul><li><p>参考Jenkins在git SSH配置</p></li><li><p><a href="https://stackoverflow.com/questions/15174194/jenkins-host-key-verification-failed" target="_blank" rel="noopener">参考地址</a></p></li></ul></li><li><p>Jenkins远程连接linux</p><p> 由于配置原因造成一下错误</p><p> 错误：jenkins.plugins.publish_over.BapPublisherException: Failed to connect session for config [131]. Message [Auth fail]</p><p> 配置方法：</p><ul><li><p>生成密钥</p><p>在我的jenkins服务器上/var/lib/jenkins用户目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen <span class="comment"># 密钥生成路径直接默认回车</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys <span class="comment"># 将公钥拷贝到authorized_keys文件</span></span><br><span class="line">scp authorized_keys user@ip:/root/.ssh <span class="comment">#将生成的authorized_keys拷贝到要连接的linux机器上的对应用户下的.ssh文件夹下</span></span><br></pre></td></tr></table></figure></li><li><p>配置SSH server  系统管理-&gt;系统设置</p><p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/590119-20170718153657958-1551906167.png" alt="系统设置"></p><p>点击测试</p><p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/590119-20170718153902255-554801851.png" alt="test ssh"></p></li><li><p><a href="https://www.cnblogs.com/wangqianqiannb/p/7200791.html" target="_blank" rel="noopener">参考连接</a></p></li></ul></li></ol><h3 id="九，总结"><a href="#九，总结" class="headerlink" title="九，总结"></a>九，总结</h3><p>​        至此yum源安装的jenkins就完毕了，之后会陆续推出相关的docker中安装jenkins，在k8s中使用jenkins的master/salves模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一，前沿&quot;&gt;&lt;a href=&quot;#一，前沿&quot; class=&quot;headerlink&quot; title=&quot;一，前沿&quot;&gt;&lt;/a&gt;一，前沿&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Jenkins是什么？&lt;br&gt;Jenkins是一个开源的支持自动化构建，部署等任务的平台。基本上可以说是持
      
    
    </summary>
    
    
      <category term="jenkins" scheme="https://hj0913.github.io/tags/jenkins/"/>
    
      <category term="centos" scheme="https://hj0913.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Harbor安装与配置</title>
    <link href="https://hj0913.github.io/2019/07/18/Harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>https://hj0913.github.io/2019/07/18/Harbor安装与配置/</id>
    <published>2019-07-18T00:26:33.000Z</published>
    <updated>2019-07-19T09:29:28.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="企业级私有镜像仓库的使用"><a href="#企业级私有镜像仓库的使用" class="headerlink" title="企业级私有镜像仓库的使用"></a>企业级私有镜像仓库的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。</p><ul><li><strong>基于角色的访问控制</strong>- 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。</li><li><strong>镜像复制</strong> - 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。</li><li><strong>图形化用户界面</strong> - 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。</li><li><strong>AD/LDAP 支持</strong> - Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理。</li><li><strong>审计管理</strong> - 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。<br>国际化 - 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。</li><li><strong>RESTful API</strong> - RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易。</li><li><strong>部署简单</strong> - 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备。</li></ul><h3 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h3><p>Harbor被部署为多个Docker容器，因此可以部署在任何支持Docker的Linux发行版上，目标主机需要Docker,并且要安装Docker Compose</p><ul><li><p>硬件</p><table><thead><tr><th>Resource</th><th>Capacity</th><th>Description</th></tr></thead><tbody><tr><td>CPU</td><td>minimal 2 CPU</td><td>4 CPU is preferred</td></tr><tr><td>Mem</td><td>minimal 4GB</td><td>8GB is preferred</td></tr><tr><td>Disk</td><td>minimal 40GB</td><td>160GB is preferred</td></tr></tbody></table></li><li><p>软件</p><table><thead><tr><th>Software</th><th>Version</th><th>Description</th></tr></thead><tbody><tr><td>Docker engine</td><td>version 17.06.0-ce+ or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">docker engine doc</a></td></tr><tr><td>Docker Compose</td><td>version 1.18.0 or higher</td><td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker compose doc</a></td></tr><tr><td>Openssl</td><td>latest is preferred</td><td>Generate certificate and keys for Harbor</td></tr></tbody></table></li><li><p>网络端口</p><table><thead><tr><th>Port</th><th>Protocol</th><th>Description</th></tr></thead><tbody><tr><td>443</td><td>HTTPS</td><td>Harbor portal and core API will accept requests on this port for https protocol, this port can change in config file</td></tr><tr><td>4443</td><td>HTTPS</td><td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled, This port can change in config file</td></tr><tr><td>80</td><td>HTTP</td><td>Harbor portal and core API will accept requests on this port for http protocol</td></tr></tbody></table></li></ul><h3 id="Harbor安装"><a href="#Harbor安装" class="headerlink" title="Harbor安装"></a>Harbor安装</h3><p>Harbor在github上的<a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">地址</a>，从readme.md中可以知道安装的<a href="https://github.com/vmware/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">方式</a>分为</p><ul><li><strong>Online installer</strong>（这是harbor的一种安装方式，与本文标题线上搭建无关联）</li><li><strong>Offline installer</strong>（本文主讲）</li><li><strong>OVA installer</strong></li></ul><p>至于Online installer和OVA installer这两种搭建方式，本文不会提及，有兴趣的同学可以自己尝试，相信在看完本文之后你也可以完成自己的Harbor仓库的搭建。</p><h4 id="Offline-installer"><a href="#Offline-installer" class="headerlink" title="Offline installer"></a>Offline installer</h4><p>在官方的<a href="https://github.com/vmware/harbor/releases" target="_blank" rel="noopener">发布版本</a>中,找到一个最新的发布版本（本文写与2019.07.18，官方version为1.8.1）</p><p>下载之后会得到一个类似于harbor-offline-installer-v1.8.1.tgz的文件，用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v1.8.1.tgz</span><br></pre></td></tr></table></figure><h5 id="Harbor目录简介"><a href="#Harbor目录简介" class="headerlink" title="Harbor目录简介"></a>Harbor目录简介</h5><ul><li>harbor.v1.8.1.tar.gz</li><li>harbor.yml 启动harbor时使用的配置文件</li><li>install.sh 是一个shell脚本启动脚本</li><li>LICENSE 该版本许可信息</li><li>prepare python写的初始化脚本</li></ul><h5 id="http安装方式"><a href="#http安装方式" class="headerlink" title="http安装方式"></a>http安装方式</h5><p>安装步骤</p><ul><li><p>配置好harbor.yml</p><p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/1563438641.jpg" alt="1563438641"></p></li><li><p>运行install.sh 或者(./prepare 再使用docker-compose up -d启动)</p></li><li><p>使用浏览器<a href="http://ip可以访问harbor的web页面" target="_blank" rel="noopener">http://ip可以访问harbor的web页面</a></p></li><li><p>其他docker客户端如何推送到该私有镜像仓库呢？</p><ul><li><p>Harbor的默认安装使用<em>HTTP</em> - 因此，您需要将该选项添加<code>--insecure-registry</code>到客户端的Docker守护程序并重新启动Docker服务。</p></li><li><p>在客户端的docker服务器中的/etc/docker/daemon.josn中配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"insecure-registry"</span>:<span class="string">"harbor服务器的ip"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>登录 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login ip -u admin -p Harbor12345</span><br></pre></td></tr></table></figure></li></ul><h5 id="https安装方式"><a href="#https安装方式" class="headerlink" title="https安装方式"></a>https安装方式</h5><ul><li><p>首先也是配置harbor.yml文件(放开https配置，配置相应的域名)</p></li><li><p>根据<a href="https://github.com/goharbor/harbor/blob/master/docs/configure_https.md" target="_blank" rel="noopener">官方</a>的文档生成对应的ssl密钥文件</p></li><li><p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/1563439550.jpg" alt="1563439550"></p></li><li><p>在对应的dockers客户端的/etc/hosts添加相应的域名解析</p></li><li><p>运行install.sh 或者(./prepare 再使用docker-compose up -d启动)</p></li><li><p>在电脑上配置 C:\Windows\System32\drivers\etc\hosts增加相应的域名解析，使用浏览器在<a href="https://ip可以访问harbor的web页面" target="_blank" rel="noopener">https://ip可以访问harbor的web页面</a></p></li><li><p>登录</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login 域名 -u admin -p Harbor12345</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;企业级私有镜像仓库的使用&quot;&gt;&lt;a href=&quot;#企业级私有镜像仓库的使用&quot; class=&quot;headerlink&quot; title=&quot;企业级私有镜像仓库的使用&quot;&gt;&lt;/a&gt;企业级私有镜像仓库的使用&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Harbor" scheme="https://hj0913.github.io/tags/Harbor/"/>
    
      <category term="Docker" scheme="https://hj0913.github.io/tags/Docker/"/>
    
      <category term="docker-compose" scheme="https://hj0913.github.io/tags/docker-compose/"/>
    
  </entry>
  
  <entry>
    <title>微服务使用场景分析</title>
    <link href="https://hj0913.github.io/2019/07/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/"/>
    <id>https://hj0913.github.io/2019/07/12/微服务使用场景分析/</id>
    <published>2019-07-12T06:33:25.000Z</published>
    <updated>2019-07-12T06:34:51.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务是什么"><a href="#微服务是什么" class="headerlink" title="微服务是什么"></a>微服务是什么</h2><h2 id="微服务能带来什么好处"><a href="#微服务能带来什么好处" class="headerlink" title="微服务能带来什么好处"></a>微服务能带来什么好处</h2><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微服务是什么&quot;&gt;&lt;a href=&quot;#微服务是什么&quot; class=&quot;headerlink&quot; title=&quot;微服务是什么&quot;&gt;&lt;/a&gt;微服务是什么&lt;/h2&gt;&lt;h2 id=&quot;微服务能带来什么好处&quot;&gt;&lt;a href=&quot;#微服务能带来什么好处&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="java" scheme="https://hj0913.github.io/tags/java/"/>
    
      <category term="微服务" scheme="https://hj0913.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>jenkins+gogs+harbor+docker自动化环境部署与安装</title>
    <link href="https://hj0913.github.io/2019/07/12/jenkins-gogs-harbor-docker%E8%87%AA%E5%8A%A8%E5%8C%96%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://hj0913.github.io/2019/07/12/jenkins-gogs-harbor-docker自动化环境部署与安装/</id>
    <published>2019-07-12T02:46:29.000Z</published>
    <updated>2019-07-12T02:53:58.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一，docker环境安装"><a href="#一，docker环境安装" class="headerlink" title="一，docker环境安装"></a>一，docker环境安装</h2><p>docker 环境的安装在官网上由相关的安装文档，将其写成ansible的脚本的形式</p><h2 id="二，gogs安装"><a href="#二，gogs安装" class="headerlink" title="二，gogs安装"></a>二，gogs安装</h2><h2 id="三，harbor安装"><a href="#三，harbor安装" class="headerlink" title="三，harbor安装"></a>三，harbor安装</h2><h2 id="四，jenkins安装"><a href="#四，jenkins安装" class="headerlink" title="四，jenkins安装"></a>四，jenkins安装</h2><h2 id="五，打包部署应用"><a href="#五，打包部署应用" class="headerlink" title="五，打包部署应用"></a>五，打包部署应用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一，docker环境安装&quot;&gt;&lt;a href=&quot;#一，docker环境安装&quot; class=&quot;headerlink&quot; title=&quot;一，docker环境安装&quot;&gt;&lt;/a&gt;一，docker环境安装&lt;/h2&gt;&lt;p&gt;docker 环境的安装在官网上由相关的安装文档，将其写成a
      
    
    </summary>
    
    
      <category term="jenkins" scheme="https://hj0913.github.io/tags/jenkins/"/>
    
      <category term="harbor" scheme="https://hj0913.github.io/tags/harbor/"/>
    
      <category term="docker" scheme="https://hj0913.github.io/tags/docker/"/>
    
      <category term="java" scheme="https://hj0913.github.io/tags/java/"/>
    
      <category term="gogs" scheme="https://hj0913.github.io/tags/gogs/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis源码分析</title>
    <link href="https://hj0913.github.io/2019/06/19/MyBatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://hj0913.github.io/2019/06/19/MyBatis源码分析/</id>
    <published>2019-06-19T13:38:48.000Z</published>
    <updated>2019-06-19T14:14:02.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatis源码分析"><a href="#MyBatis源码分析" class="headerlink" title="MyBatis源码分析"></a>MyBatis源码分析</h2><h3 id="MyBatis运行过程"><a href="#MyBatis运行过程" class="headerlink" title="MyBatis运行过程"></a>MyBatis运行过程</h3><ul><li><p>传统的JDBC编程查询数据库代码和过程总结</p><ol><li>加载驱动</li><li>创建连接，Connection对象</li><li>根据Connection创建Statement或者PreparedStatement来执行 sql 语句</li><li>返回结果集到 ResultSet 中</li><li>手动将ResultSet映射到JavaBean中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明Connection对象</span></span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//遍历查询结果集</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//加载驱动程序</span></span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        <span class="comment">//创建 connection 对象</span></span><br><span class="line">        con = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/db"</span>, <span class="string">"username"</span>, <span class="string">"password"</span>);</span><br><span class="line">        <span class="comment">//使用 connection 对象创建statement 或者 PreparedStatement 类对象，用来执行SQL语句</span></span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        <span class="comment">//要执行的SQL语句</span></span><br><span class="line">        String sql = <span class="string">"select * from emp"</span>;</span><br><span class="line">        <span class="comment">//3.ResultSet类，用来存放获取的结果集！！</span></span><br><span class="line">        ResultSet rs = statement.executeQuery(sql);</span><br><span class="line">      String job = <span class="string">""</span>;</span><br><span class="line">        String id = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            <span class="comment">//获取stuname这列数据</span></span><br><span class="line">            job = rs.getString(<span class="string">"job"</span>);</span><br><span class="line">            <span class="comment">//获取stuid这列数据</span></span><br><span class="line">            id = rs.getString(<span class="string">"ename"</span>);</span><br><span class="line">            <span class="comment">//输出结果</span></span><br><span class="line">            System.out.println(id + <span class="string">""</span> + job);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">//数据库连接失败异常处理</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rs.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>MyBatis具体流程</p><ol><li>使用配置文件构建SqlSessionFactory</li><li>使用SqlSessionFactory获得SqlSession，SqlSession相当于传统JDBC的Connection</li><li>使用SqlSession得到Mapper</li><li>用Mapper来执行sql语句，并返回结果直接封装到JavaBean中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//获取 sqlSession，sqlSession 相当于传统 JDBC 的 Conection</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"> InputStream configFile = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line"> SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder.build(configFile);</span><br><span class="line"> <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用 sqlSession 获得对应的 mapper，mapper 用来执行 sql 语句。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">get</span><span class="params">(SqlSession sqlSession, <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line"> UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"> <span class="keyword">return</span> userMapper.selectByPrimaryKey(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>总结</p><ol><li>初始化阶段 –&gt; 读写XML配置文件和注解中的配置信息，创建配置信息，并完成各个模块的初始化工作</li><li>代理阶段  –&gt; 封装batis编程模型，使用mapper接口开发的初始化工作</li><li>数据读写阶段 –&gt; 通过sqlSession完成sql的解析，参数的映射，SQL的执行和结果反射的过程</li></ol></li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MyBatis源码分析&quot;&gt;&lt;a href=&quot;#MyBatis源码分析&quot; class=&quot;headerlink&quot; title=&quot;MyBatis源码分析&quot;&gt;&lt;/a&gt;MyBatis源码分析&lt;/h2&gt;&lt;h3 id=&quot;MyBatis运行过程&quot;&gt;&lt;a href=&quot;#MyBati
      
    
    </summary>
    
    
      <category term="Java" scheme="https://hj0913.github.io/tags/Java/"/>
    
      <category term="MyBatis" scheme="https://hj0913.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://hj0913.github.io/2019/06/12/Maven/"/>
    <id>https://hj0913.github.io/2019/06/12/Maven/</id>
    <published>2019-06-12T11:40:41.000Z</published>
    <updated>2019-06-12T11:40:41.555Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sonar+maven+jenkins架构搭建</title>
    <link href="https://hj0913.github.io/2019/06/12/sonar-maven-jenkins%E6%9E%B6%E6%9E%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://hj0913.github.io/2019/06/12/sonar-maven-jenkins架构搭建/</id>
    <published>2019-06-12T09:35:31.000Z</published>
    <updated>2019-06-12T12:31:25.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sonar安装"><a href="#sonar安装" class="headerlink" title="sonar安装"></a>sonar安装</h3><ul><li><h3 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h3></li></ul><h3 id="配置Jenkins"><a href="#配置Jenkins" class="headerlink" title="配置Jenkins"></a>配置Jenkins</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;sonar安装&quot;&gt;&lt;a href=&quot;#sonar安装&quot; class=&quot;headerlink&quot; title=&quot;sonar安装&quot;&gt;&lt;/a&gt;sonar安装&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;配置Maven&quot;&gt;&lt;a href=&quot;#配置Maven&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="sonar" scheme="https://hj0913.github.io/tags/sonar/"/>
    
      <category term="Jenkins" scheme="https://hj0913.github.io/tags/Jenkins/"/>
    
      <category term="Maven" scheme="https://hj0913.github.io/tags/Maven/"/>
    
  </entry>
  
</feed>
