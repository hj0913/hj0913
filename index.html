<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">

    

    

    <title>黄杰|博客</title>
    <meta name="author" content="Huang Jie">
    <meta name="version" content="1.0.0">
    <meta name="keywords" content>
    <meta name="description" content>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">

    
    <link rel="alternate" href="/atom.xml" title="黄杰|博客" type="application/atom+xml">
    
    
    <link rel="icon" href="/images/favicon.ico">
    

    <link rel="stylesheet" href="/css/style.css">
</head>
<body>

    <main class="app">
        <header class="header clearfix">
    <div id="nav" class="nav">
    <div class="nav-mobile">
        <button id="open-panel" class="open-panel nav-mobile-item"><i class="icon-documents"></i></button>
        <h1 class="nav-mobile-title nav-mobile-item">黄杰|博客</h1>
        <button id="open-menus" class="open-panel nav-mobile-item"><i class="icon-library"></i></button>
    </div>

    <nav id="nav-inner" class="nav-inner">
        
            <a class="nav-item active" href="/">
                <span class="nav-text">首页</span>
            </a>
        
            <a class="nav-item" href="/tags">
                <span class="nav-text">标签</span>
            </a>
        
            <a class="nav-item" href="/archives">
                <span class="nav-text">归档</span>
            </a>
        
            <a class="nav-item" href="/atom.xml">
                <span class="nav-text">订阅</span>
            </a>
        
            <a class="nav-item" href="/about">
                <span class="nav-text">关于</span>
            </a>
        
    </nav>
</div>

    <aside id="aside" class="aside">
    <div id="aside-mask" class="aside-mask"></div>
    <div id="aside-inner" class="aside-inner">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://hj0913.github.io"></form>

        
        

        
        <div class="author-meta">
            
            <div class="author-avatar">
                <a href="/">
                    <img src="/images/avatar.jpg" title="HuangJie">
                </a>
            </div>
            
            <div class="author-name">HuangJie</div>
            <div class="author-work"></div>
            <div class="author-location">
                <i class="icon-location vm"></i>
                <span class="vm">Nanchang, China</span>
            </div>
            
            <div class="author-thread-wrap">
                <div class="author-threads clearfix">
                    
                        <a class="thread-item" href="https://github.com/hj0913" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512 32.12c-265.004 0-479.88 220.23-479.88 492.090 0 217.446 137.536 401.684 328.202 466.81 23.994 4.498 32.778-10.712 32.778-23.78 0-11.782-0.428-42.632-0.642-83.764-133.466 29.778-161.744-65.984-161.744-65.984-21.852-56.772-53.344-71.982-53.344-71.982-43.49-30.636 3.214-29.992 3.214-29.992 48.202 3.428 73.482 50.772 73.482 50.772 42.846 75.196 112.258 53.558 139.68 40.918 4.284-31.706 16.71-53.558 30.42-65.77-106.474-12.426-218.516-54.63-218.516-243.152 0-53.772 18.638-97.69 49.274-131.966-4.928-12.426-21.424-62.556 4.714-130.252 0 0 40.276-13.282 131.966 50.344 38.348-10.926 79.266-16.282 120.184-16.496 40.704 0.214 81.836 5.57 120.184 16.496 91.692-63.626 131.752-50.344 131.752-50.344 26.136 67.698 9.64 117.828 4.714 130.252 30.636 34.492 49.274 78.408 49.274 131.966 0 188.952-112.258 230.514-219.16 242.724 17.138 15.21 32.564 45.202 32.564 91.048 0 65.77-0.642 118.898-0.642 134.966 0 13.068 8.57 28.492 32.992 23.566 191.094-64.912 328.418-249.152 328.418-466.382 0-271.86-214.874-492.090-479.88-492.090z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="http://weibo.com/sanonz" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M21.332 512c0-270.988 219.68-490.666 490.668-490.666s490.666 219.68 490.666 490.666c0 270.988-219.678 490.666-490.666 490.666s-490.666-219.678-490.666-490.666zM960 512c0-247.424-200.576-448-448-448s-448 200.576-448 448c0 247.424 200.576 448 448 448s448-200.576 448-448zM768 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.206 85.332 85.332 85.332zM512 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.206-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332zM255.998 597.332c47.128 0 85.332-38.206 85.332-85.332s-38.204-85.332-85.332-85.332c-47.128 0-85.332 38.204-85.332 85.332s38.204 85.332 85.332 85.332z"/>
</svg>

                        </a>
                    
                        <a class="thread-item" href="https://twitter.com" target="_blank" rel="noopener">
                            <!-- Generated by IcoMoon.io -->
<svg viewbox="0 0 1024 1024" width="38" height="38" fill="currentColor">
<path d="M512.029 31.011c-263.32 0-476.784 213.502-476.784 476.784 0 263.32 213.464 476.743 476.784 476.743s476.743-213.424 476.743-476.743c0-263.282-213.444-476.784-476.743-476.784zM752.193 411.663c0.251 5.151 0.349 10.319 0.349 15.548 0 158.786-120.856 341.85-341.85 341.85-67.844 0-131.021-19.884-184.188-53.961 9.41 1.104 18.955 1.665 28.656 1.665 56.305 0 108.115-19.208 149.221-51.425-52.567-0.987-96.925-35.741-112.22-83.468 7.32 1.433 14.85 2.149 22.595 2.149 10.959 0 21.569-1.433 31.656-4.201-54.987-11.035-96.402-59.634-96.402-117.796 0-0.524 0-1.025 0.020-1.549 16.186 9.003 34.716 14.404 54.427 15.044-32.258-21.587-53.458-58.317-53.458-100.023 0-22.015 5.925-42.673 16.264-60.408 59.266 72.683 147.807 120.527 247.676 125.521-2.053-8.77-3.118-17.968-3.118-27.378 0-66.333 53.787-120.14 120.158-120.14 34.561 0 65.771 14.599 87.69 37.93 27.378-5.363 53.091-15.393 76.305-29.16-9.003 28.074-28.036 51.618-52.858 66.47 24.338-2.903 47.495-9.37 69.024-18.917-16.070 24.144-36.459 45.306-59.945 62.248z"/>
</svg>

                        </a>
                    
                </div>
            </div>
            
        </div>
        
    </div>
</aside>

</header>

        <div id="content" class="content">
    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/08/13/SQL优化/">SQL优化</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-08-13T11:04:00.000Z" itemprop="datePublished">2019-08-13</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JAVA面试/">JAVA面试</a>, <a class="article-tag-link" href="/tags/SQL/">SQL</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="SQL优化方案"><a href="#SQL优化方案" class="headerlink" title="SQL优化方案"></a>SQL优化方案</h2><h3 id="一，SQL语句性能优化"><a href="#一，SQL语句性能优化" class="headerlink" title="一，SQL语句性能优化"></a>一，SQL语句性能优化</h3><ol>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by 涉及的列上建立索引</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，创建表时NULL是默认值，但大多数时候应该使用NOT NULL，或者使用一个特殊的值，如0，-1作为默 认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>可以在 num 上设置默认值 0,确保表中 num 列没有 null 值，然后这样查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符， MySQL只有对以下操作符才使用索引：&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE。</p>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件， 否则将导致引擎放弃使用索引而进行全表扫描， 可以 使用UNION合并查询：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">or</span> <span class="keyword">num</span>=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以这样查询:<br>   <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">20</span></span><br></pre></td></tr></table></figure></p>
<ol start="5">
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p> 对于连续的数值，能用 between 就不要用 in 了：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="6">
<li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优 化程序不能将访问计划的选择推迟到运行时;它必须在编译时进行选择。然 而，如果在编译时建立访问计 划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>

<p>可以改为强制查询使用索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">with</span>(<span class="keyword">index</span>(索引名)) <span class="keyword">where</span> <span class="keyword">num</span>=@<span class="keyword">num</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作， 这将导致引擎放弃使用索引而进行全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span>=<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>=<span class="number">100</span>*<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>)=<span class="string">'abc'</span>;<span class="comment">#name 以 abc 开头的 id</span></span><br></pre></td></tr></table></figure>

<p>应改为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'abc%'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用 索引。</p>
</li>
</ol>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/08/06/k8s二进制部署-HTTPS-RBAC/">k8s二进制部署(HTTPS+RBAC)</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-08-06T00:47:10.000Z" itemprop="datePublished">2019-08-06</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/docker/">docker</a>, <a class="article-tag-link" href="/tags/k8s/">k8s</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="k8s二进制部署-HTTPS-RBAC"><a href="#k8s二进制部署-HTTPS-RBAC" class="headerlink" title="k8s二进制部署(HTTPS+RBAC)"></a>k8s二进制部署(HTTPS+RBAC)</h3><h4 id="官方提供的几种Kubernetes部署方式"><a href="#官方提供的几种Kubernetes部署方式" class="headerlink" title="官方提供的几种Kubernetes部署方式"></a>官方提供的几种Kubernetes部署方式</h4><ul>
<li><p><strong>minikube</strong></p>
<p>​        Minikube是一个工具，可以在本地快速运行一个单点的Kubernetes，尝试Kubernetes或日常开发的用户使用。不能用于生产环境。</p>
<p>官方地址：<a href="https://kubernetes.io/docs/setup/minikube/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/minikube/</a></p>
</li>
<li><p><strong>kubeadm</strong></p>
<p>​        Kubeadm也是一个工具，提供kubeadm init和kubeadm join，用于快速部署Kubernetes集群。</p>
<p>官方地址：<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/</a></p>
</li>
<li><p><strong>二进制包</strong></p>
<p>​        从官方下载发行版的二进制包，手动部署每个组件，组成Kubernetes集群。<br><strong>小结：</strong></p>
<p>​        生产环境中部署Kubernetes集群，只有Kubeadm和二进制包可选，Kubeadm降低部署门槛，但屏蔽了很多细节，遇到问题很难排查。我们这里使用二进制包部署Kubernetes集群，我也是推荐大家使用这种方式，虽然手动部署麻烦点，但学习很多工作原理，更有利于后期维护。</p>
</li>
</ul>
<p>参考地址：<a href="https://blog.51cto.com/lizhenliang/2325770" target="_blank" rel="noopener">李振良博客</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/08/05/JAVA集合总结/">JAVA集合总结</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-08-05T02:20:30.000Z" itemprop="datePublished">2019-08-05</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/JAVA/">JAVA</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="JAVA集合总结"><a href="#JAVA集合总结" class="headerlink" title="JAVA集合总结"></a>JAVA集合总结</h3><h4 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h4><ul>
<li><p>概述</p>
<p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，<strong>并允许使用 null 值和 null 键</strong>。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</li>
</ul>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/24/分布式事务探索/">分布式事务探索</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-24T09:43:57.000Z" itemprop="datePublished">2019-07-24</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/分布式/">分布式</a>, <a class="article-tag-link" href="/tags/微服务/">微服务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不知道你是否遇到过这样的情况，去小卖铺买东西，付了钱，但是店主因为处理了一些其他事，居然忘记你付了钱，又叫你重新付。又或者在网上购物明明已经扣款，但是却告诉我没有发生交易。这一系列情况都是因为没有事务导致的。这说明了事务在生活中的一些重要性。有了事务，你去小卖铺买东西，那就是一手交钱一手交货。有了事务，你去网上购物，扣款即产生订单交易。</p>
<h3 id="事务的具体定义"><a href="#事务的具体定义" class="headerlink" title="事务的具体定义"></a>事务的具体定义</h3><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。</p>
<h3 id="数据库本地事务"><a href="#数据库本地事务" class="headerlink" title="数据库本地事务"></a>数据库本地事务</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>说到数据库事务就不得不说，数据库事务中的四大特性，ACID:</p>
<ul>
<li>A:原子性(Atomicity)<br>一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>就像你买东西要么交钱收货一起都执行，要么要是发不出货，就退钱。</li>
<li>C:一致性(Consistency)<br>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</li>
<li>I:隔离性(Isolation)<br>指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。<br>打个比方，你买东西这个事情，是不影响其他人的。</li>
<li>D:持久性(Durability)<br>指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。<br>打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。<h4 id="InnoDB实现原理"><a href="#InnoDB实现原理" class="headerlink" title="InnoDB实现原理"></a>InnoDB实现原理</h4>InnoDB是mysql的一个存储引擎，大部分人对mysql都比较熟悉，这里简单介绍一下数据库事务实现的一些基本原理，在本地事务中，服务和资源在事务的包裹下可以看做是一体的:<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/164d65a2768cd3d6.JPG" alt="事务"><br>我们的本地事务由资源管理器进行管理:<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard.png" alt="InnoDB"><br>而事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。 和Undo Log相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。 对具体实现过程有兴趣的同学可以去自行搜索扩展。<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h4>分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。<h4 id="分布式事务产生的原因"><a href="#分布式事务产生的原因" class="headerlink" title="分布式事务产生的原因"></a>分布式事务产生的原因</h4>从上面本地事务来看，我们可以看为两块，一个是service产生多个节点，另一个是resource产生多个节点。<h5 id="service多个节点"><a href="#service多个节点" class="headerlink" title="service多个节点"></a>service多个节点</h5>随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard1.png" alt="service多个节点"><br>这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。<h5 id="resource多个节点"><a href="#resource多个节点" class="headerlink" title="resource多个节点"></a>resource多个节点</h5>同样的，互联网发展得太快了，我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard2.png" alt="resource多个节点"><h4 id="分布式事务的基础"><a href="#分布式事务的基础" class="headerlink" title="分布式事务的基础"></a>分布式事务的基础</h4>从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:<h5 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h5>从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:<h3 id="CAP-1"><a href="#CAP-1" class="headerlink" title="CAP"></a>CAP</h3>CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。</li>
<li>C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</li>
<li>A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。</li>
<li>P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。<br>熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。<br>对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。<br>对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。<br>顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。<h5 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h5>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展</li>
</ul>
<ol>
<li>基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li>
<li>软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。</li>
<li>最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。<br>BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。<h4 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h4>有了上面的理论基础后，这里介绍开始介绍几种常见的分布式事务的解决方案。<h5 id="是否真的要分布式事务"><a href="#是否真的要分布式事务" class="headerlink" title="是否真的要分布式事务"></a>是否真的要分布式事务</h5>在说方案之前，首先你一定要明确你是否真的需要分布式事务？<br>上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪，而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。<br>如果你确定需要引入分布式事务可以看看下面几种常见的方案。<h5 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h5>说到2PC就不得不聊数据库分布式事务中的 XA Transactions。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard3.png" alt="2PC"><br>在XA协议中分为两阶段:<br>第一阶段：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.<br>第二阶段：事务协调器要求每个数据库提交数据，或者回滚数据。<br>优点： 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。<br>缺点:</li>
</ol>
<ul>
<li>单点问题:事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</li>
<li>同步阻塞:在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</li>
<li>数据不一致:两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。<br>总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。<h5 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h5>关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。 TCC事务机制相比于上面介绍的XA，解决了其几个缺点: 1.解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。 2.同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 3.数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard4.png" alt="TCC"><br>对于TCC的解释:</li>
<li>Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</li>
<li>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li>
<li>Cancel阶段：取消执行，释放Try阶段预留的业务资源 Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。<br>举个简单的例子如果你用100元买了一瓶水， Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。<br>如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。<br>如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)<br>对于TCC来说适合一些:</li>
<li>强隔离性，严格一致性要求的活动业务。</li>
<li>执行时间较短的业务<br>实现参考:ByteTCC:<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fliuyangming%2FByteTCC%2F" target="_blank" rel="noopener">github.com/liuyangming…</a><h5 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h5>本地消息表这个方案最初是ebay提出的 ebay的完整方案<a href="https://queue.acm.org/detail.cfm?id=1394128。" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128。</a><br>此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行。消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试。人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard5.png" alt="本地消息表"><br>对于本地消息队列来说核心是把大事务转变为小事务。还是举上面用100元去买一瓶水的例子。</li>
</ul>
<p>1.当你扣钱的时候，你需要在你扣钱的服务器上新增加一个本地消息表，你需要把你扣钱和写入减去水的库存到本地消息表放入同一个事务(依靠数据库本地事务保证一致性。<br>2.这个时候有个定时任务去轮询这个本地事务表，把没有发送的消息，扔给商品库存服务器，叫他减去水的库存，到达商品服务器之后这个时候得先写入这个服务器的事务表，然后进行扣减，扣减成功后，更新事务表中的状态。<br>3.商品服务器通过定时任务扫描消息表或者直接通知扣钱服务器，扣钱服务器本地消息表进行状态更新。<br>4.针对一些异常情况，定时扫描未成功处理的消息，进行重新发送，在商品服务器接到消息之后，首先判断是否是重复的，如果已经接收，在判断是否执行，如果执行在马上又进行通知事务，如果未执行，需要重新执行需要由业务保证幂等，也就是不会多扣一瓶水。<br>本地消息队列是BASE理论，是最终一致模型，适用于对一致性要求不高的。实现这个模型时需要注意重试的幂等。</p>
<h5 id="MQ事务"><a href="#MQ事务" class="headerlink" title="MQ事务"></a>MQ事务</h5><p>在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，下面简单介绍一下MQ事务，如果想对其详细了解可以参考:<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F453c6e7ff81c%E3%80%82" target="_blank" rel="noopener">www.jianshu.com/p/453c6e7ff…</a><br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard6.png" alt="MQ事务1"><br>基本流程如下: 第一阶段Prepared消息，会拿到消息的地址。<br>第二阶段执行本地事务。<br>第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。消息接受者就能使用这个消息。<br>如果确认消息失败，在RocketMq Broker中提供了定时扫描没有更新状态的消息，如果有消息没有得到确认，会向消息发送者发送消息，来判断是否提交，在rocketmq中是以listener的形式给发送者，用来处理。<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/dis-transaction/clipboard7.png" alt="MQ事务2"><br>如果消费超时，则需要一直重试，消息接收端需要保证幂等。如果消息消费失败，这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失</p>
<h5 id="Saga事务"><a href="#Saga事务" class="headerlink" title="Saga事务"></a>Saga事务</h5><p>Saga是30年前一篇数据库伦理提到的一个概念。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。 Saga的组成：<br>每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。 可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。<br>Saga的执行顺序有两种：<br>T1, T2, T3, …, Tn<br>T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n Saga定义了两种恢复策略：<br>向后恢复，即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。 向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。<br>这里要注意的是，在saga模式中不能保证隔离性，因为没有锁住资源，其他事务依然可以覆盖或者影响当前事务。<br>还是拿100元买一瓶水的例子来说，这里定义<br>T1=扣100元 T2=给用户加一瓶水 T3=减库存一瓶水<br>C1=加100元 C2=给用户减一瓶水 C3=给库存加一瓶水<br>我们一次进行T1,T2，T3如果发生问题，就执行发生问题的C操作的反向。 上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题<br>可以看见saga模式没有隔离性的影响还是较大，可以参照华为的解决方案:从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源。也可以在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。<br>具体实例:可以参考华为的servicecomb</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>还是那句话，能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。上面对解决方案只是一些简单介绍，如果真正的想要落地，其实每种方案需要思考的地方都非常多，复杂度都比较大，所以最后再次提醒一定要判断好是否使用分布式事务。最后在总结一些问题,大家可以下来自己从文章找寻答案:</p>
<ol>
<li>ACID和CAP的 CA是一样的吗？</li>
<li>分布式事务常用的解决方案的优缺点是什么？适用于什么场景？</li>
<li>分布式事务出现的原因？用来解决什么痛点？<br>转自作者：咖啡拿铁<br>转自链接：<a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b" target="_blank" rel="noopener">https://juejin.im/post/5b5a0bf9f265da0f6523913b</a><br>转自来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
</ol>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/24/docker-swarm模式下Springcloud容器相互注册/">docker-swarm模式下Springcloud容器相互注册</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-24T08:04:10.000Z" itemprop="datePublished">2019-07-24</time>
</a>

            

        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/23/修改docker日志目录/">修改docker日志目录</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-23T04:35:54.000Z" itemprop="datePublished">2019-07-23</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/docker/">docker</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <p>默认安装完成docker后docker的所有images及相关信息存储位置为：/var/lib/docker</p>
<p>镜像默认路径: /var/lib/docker/containers/</p>
<p>而通常我们的系统盘挂载一般不会很大，所以需要将其移到其他分区，我们可以采用</p>
<h3 id="一，软链接的方式"><a href="#一，软链接的方式" class="headerlink" title="一，软链接的方式"></a>一，软链接的方式</h3><ol>
<li><p>首先暂停docker服务</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件移到指定目录</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/lib</span><br><span class="line"><span class="comment"># 文件复制</span></span><br><span class="line">mv docker/* /home/docker-log</span><br><span class="line"><span class="comment"># 删除原来/var/lib下的docker文件夹</span></span><br><span class="line">rm -rf docker</span><br><span class="line"><span class="comment"># 进入/dome/docker-log创建软连接</span></span><br><span class="line">ln -s /home/docker-log /var/lib/docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启服务</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker.service</span><br><span class="line">docker info <span class="comment"># 查看是否成功</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="二，修改镜像和容器的存放路径"><a href="#二，修改镜像和容器的存放路径" class="headerlink" title="二，修改镜像和容器的存放路径"></a>二，修改镜像和容器的存放路径</h3><p>指定镜像和容器存放路径的参数是–graph=/var/lib/docker，我们只需要修改配置文件指定启动参数即可。</p>
<p>Docker 的配置文件可以设置大部分的后台进程参数，在各个操作系统中的存放位置不一致，在 Ubuntu 中的位置是：/etc/default/docker，在 CentOS 中的位置是：/etc/sysconfig/docker。</p>
<p>如果是 CentOS6 则添加下面这行：</p>
<p>OPTIONS=–graph=”/root/data/docker” –selinux-enabled -H fd://</p>
<p>如果是 Ubuntu 则添加下面这行（因为 Ubuntu 默认没开启 selinux）：</p>
<p>OPTIONS=–graph=”/root/data/docker” -H fd://# 或者DOCKER_OPTS=”-g /root/data/docker”</p>
<p>最后重新启动，Docker 的路径就改成 /root/data/docker 了。</p>
<p>centos7下，也可以</p>
<p>修改docker.service文件，使用-g参数指定存储位置</p>
<p>vi /usr/lib/systemd/system/docker.service  </p>
<p>ExecStart=/usr/bin/dockerd –graph /new-path/docker </p>
<p> // reload配置文件 </p>
<p>systemctl daemon-reload </p>
<p> // 重启docker </p>
<p>systemctl restart docker.service</p>
<p><font color="red"><strong>如果docker是1.12或以上的版本，可以修改（或新建）daemon.json文件。修改后会立即生效，不需重启docker服务。</strong></font></p>
<p>vim /etc/docker/daemon.json </p>
<p>{“registry-mirrors”: [“<a href="http://7e61f7f9.m.daocloud.io&quot;],&quot;graph&quot;" target="_blank" rel="noopener">http://7e61f7f9.m.daocloud.io&quot;],&quot;graph&quot;</a>: “/new-path/docker”}</p>
<h3 id="三，system下创建配置文件"><a href="#三，system下创建配置文件" class="headerlink" title="三，system下创建配置文件"></a>三，system下创建配置文件</h3><p>在/etc/systemd/system/docker.service.d 目录下创建一个Drop-In文件“docker.conf”，默认 docker.service.d 文件夹不存在。所以你必须先创建它。</p>
<p>创建Drop-In 文件的原因，是我们希望Docker 服务，使用docker.conf文件中提到的特定参数，将默认服务所使用的位于/lib/systemd/system/docker.service文件中的参数进行覆盖。如果你想深入了解Drop-In，请阅读<a href="https://goo.gl/7KzBGT" target="_blank" rel="noopener">system.unit</a>文档</p>
<p><strong>定义新的存储位置</strong>现在打开docker.conf增加如下内容：</p>
<p># sudo vi /etc/systemd/system/docker.service.d/docker.conf </p>
<p>[Service] </p>
<p>ExecStart= </p>
<p>ExecStart=/usr/bin/dockerd –graph=”/mnt/new_volume” –storage-driver=devicemapper</p>
<p>保存并退出VI编辑器，/mnt/new_volume 是新的存储位置，而devicemapper是当前docker所使用的存储驱动。如果你的存储驱动有所不同，请输入之前第一步查看并记下的值。Docker<a href="https://goo.gl/VnHP61" target="_blank" rel="noopener">官方文档</a>中提供了更多有关各种存储驱动器的信息。现在，你可以重新加载服务守护程序，并启动Docker服务了。这将改变新的镜像和容器的存储位置。</p>
<p># sudo systemctl daemon-reload </p>
<p># sudo systemctl start docker</p>
<p>为了确认一切顺利，运行 # docker info 命令检查Docker 的根目录.它将被更改为/mnt/new_volume</p>
<h3 id="四，使用docker-storage-set（docker1-12）命令进行配置"><a href="#四，使用docker-storage-set（docker1-12）命令进行配置" class="headerlink" title="四，使用docker-storage-set（docker1.12）命令进行配置"></a>四，使用docker-storage-set（docker1.12）命令进行配置</h3><p>配置文件位置：<strong>/usr/lib/docker-storage-setup/docker-storage-setup</strong>或者<strong>/etc/sysconfig/docker-storage-setup、/etc/sysconfig/docker-storage</strong></p>
<p>vim /etc/sysconfig/docker-storage</p>
<p># This file may be automatically generated by an installation program.</p>
<p># Please DO NOT edit this file directly. Instead edit</p>
<p># /etc/sysconfig/docker-storage-setup and/or refer to</p>
<p># “man docker-storage-setup”.</p>
<p># By default, Docker uses a loopback-mounted sparse file in</p>
<p># /var/lib/docker.  The loopback makes it slower, and there are some</p>
<p># restrictive defaults, such as 100GB max storage.</p>
<p>DOCKER_STORAGE_OPTIONS=–graph=”要保存的路径”</p>
<p>或者</p>
<p>DEVS=/dev/vdb</p>
<p>DATA_SIZE=800GB（更改docker默认存储大小）</p>
<p><a href="https://blog.51cto.com/forangela/1949947" target="_blank" rel="noopener">参考连接</a></p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/18/jenkins安装-yum源安装/">jenkins安装(yum源安装)</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-18T07:40:36.000Z" itemprop="datePublished">2019-07-18</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/centos/">centos</a>, <a class="article-tag-link" href="/tags/jenkins/">jenkins</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h3 id="一，前沿"><a href="#一，前沿" class="headerlink" title="一，前沿"></a>一，前沿</h3><ol>
<li><p>Jenkins是什么？<br>Jenkins是一个开源的支持自动化构建，部署等任务的平台。基本上可以说是持续集成(CI),持续发布(CD)不可缺的工具。Jenkins的<a href="https;//jenkins.io">官方地址</a></p>
</li>
<li><p>本篇环境信息</p>
<table>
<thead>
<tr>
<th>工具/环境</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>Linux Server</td>
<td>CentOS 7</td>
</tr>
<tr>
<td>Jenkins</td>
<td>2.121.2</td>
</tr>
<tr>
<td>JDK</td>
<td>1.8.0_181</td>
</tr>
</tbody></table>
</li>
<li><p>准备工作<br>安装jdk,安装maven</p>
<h3 id="二，安装Jenkins"><a href="#二，安装Jenkins" class="headerlink" title="二，安装Jenkins"></a>二，安装Jenkins</h3></li>
<li><p>yum源的安装</p>
<ul>
<li><p>yum源导入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加Yum源</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"><span class="comment">#导入密钥</span></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y jenkins</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>开放端口<br>Jenkins站点的默认监听端口是8080</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --add-port=8080/tcp --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置Java可选路径<br> 因为Jenkins默认的java可选路径不包含我们部署的jdk路径，所以这里要配置一下，不然Jenkins服务会启动失败</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改jenkins启动脚本</span></span><br><span class="line">sudo vi /etc/init.d/jenkins</span><br><span class="line"><span class="comment">#修改candidates增加java可选路径：/usr/java/jdk1.8.0_181/bin/java</span></span><br><span class="line">candidates=<span class="string">"</span></span><br><span class="line"><span class="string">/etc/alternatives/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/java-1.8.0/bin/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/jre-1.8.0/bin/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/java-1.7.0/bin/java</span></span><br><span class="line"><span class="string">/usr/lib/jvm/jre-1.7.0/bin/java</span></span><br><span class="line"><span class="string">/usr/bin/java</span></span><br><span class="line"><span class="string">/usr/java/jdk1.8.0_181/bin/java</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动Jenkins并设置Jenkins开机启动</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重载服务（由于前面修改了Jenkins启动脚本）</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="comment">#启动Jenkins服务</span></span><br><span class="line">sudo systemctl start jenkins</span><br><span class="line"><span class="comment">#将Jenkins服务设置为开机启动</span></span><br><span class="line"><span class="comment">#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令</span></span><br><span class="line">sudo /sbin/chkconfig jenkins on</span><br></pre></td></tr></table></figure>

<p> 浏览器输入 http://<ip address>:8080 访问Jenkins</ip></p>
<h3 id="三，Jenkins初始化"><a href="#三，Jenkins初始化" class="headerlink" title="三，Jenkins初始化"></a>三，Jenkins初始化</h3></li>
<li><p>解锁Jenkins<br> 查询root账号默认密码</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<p> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkinsstart.png" alt="jenkins初始化"></p>
</li>
<li><p>选择插件<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins-getting-started-plugin-select.png-kblb.png" alt="jenkins选择插件"><br> 可以选择安装推荐的插件，也可以选择自定义的插件安装，其中这里我选择了第二种。<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-plugin-init.png-kblb.png" alt="jenkins初始化安装插件"></p>
</li>
<li><p>添加管理员<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-admin-add.png-kblb.png" alt="创建用户"></p>
</li>
<li><p>配置Jenkins URL<br>如果由域名的话可以填入域名，之后也可以修改；在系统管理=&gt;系统设置 <strong>Jenkins Location</strong>中设置<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-config-url.png-kblb.png" alt="配置URL"></p>
</li>
<li><p>开始使用Jenkins<br>配置完Jenkins URL之后就完成了整个Jenkins配置引导<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-getting-started-done.png-kblb.png" alt="开始Jenkins"></p>
</li>
<li><p>点击“开始使用Jenkins”就会进入Jenkins主页<br> <img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/jenkins-home.png-kblb.png" alt="Jenkins的主页"></p>
</li>
</ol>
<h3 id="四，Jenkins与git-SSH配置"><a href="#四，Jenkins与git-SSH配置" class="headerlink" title="四，Jenkins与git SSH配置"></a>四，Jenkins与git SSH配置</h3><ol>
<li><p>首先在jenkins服务器上安装相对应的git工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装好git服务器，可以用gogs，GitLab或者直接使用github，gitee等仓库</p>
</li>
<li><p>在Jenkins服务器配置相对应的.ssh目录下配置config</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host git.***.com(你设置的jenkins能访问到的git域名)</span><br><span class="line">    HostName git.***.com</span><br><span class="line">    Port 10022(开放的git服务ssh端口)</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa(设置的公钥与私钥对应)</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure>

<p>在git服务上进行相对应的ssh配置将jenkins生成的id_rsa.pub文件</p>
</li>
<li><p>这样配置你的jenkins服务器上应该能够clone相关的代码。如果jenkins服务与git服务放在一台服务上jenkins的web服务应该能拉取相关的代码，如果2台分开部署如何配置呢？</p>
</li>
<li><p>在jenkins的安装目录下进行ssh配置在/var/lib/jenkins创建相关的.ssh文件，设置相关的config以及私钥</p>
</li>
<li><p>在jenkins的web页面进行相关的配置将相对应的配置创建相关的密钥对应</p>
</li>
</ol>
<h3 id="五，Jenkins中JAVA-MAVEN配置"><a href="#五，Jenkins中JAVA-MAVEN配置" class="headerlink" title="五，Jenkins中JAVA,MAVEN配置"></a>五，Jenkins中JAVA,MAVEN配置</h3><ol>
<li>在jenkins服务器中安装相对应的JAVA环境，然后再系统管理中全局环境变量设置相对应的JAVA_HOME的环境</li>
<li>maven配置，安装相关的maven插件Pipeline Maven Integration，配置相关的.m2文件</li>
</ol>
<h3 id="六，在Jenkins中配置nodejs"><a href="#六，在Jenkins中配置nodejs" class="headerlink" title="六，在Jenkins中配置nodejs"></a>六，在Jenkins中配置nodejs</h3><ol>
<li><p>在centos中安装nodejs</p>
<ul>
<li><p>新建目录/opt/mnt</p>
</li>
<li><p>选择你相应的版本<a href="https://nodejs.org/zh-cn/download/releases/" target="_blank" rel="noopener">官网下载对应的版本</a></p>
</li>
<li><p>下载nodejs</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nodejs.org/download/release/v8.12.0/node-v8.12.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p>解压</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxcf -C node-v8.12.0-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>进入解压目录下的bin目录,执行ls命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv node-v8.12.0-linux-x64 node</span><br><span class="line"><span class="built_in">cd</span> node/bin &amp;&amp; ls</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>有node和npm

测试

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node -v</span><br></pre></td></tr></table></figure>


显示版本号即代表成功</code></pre><ul>
<li><p>现在 <code>node</code> 和 <code>npm</code> 还不能全局使用，做个链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /opt/mnt/node/bin/node /usr/<span class="built_in">local</span>/bin/node</span><br><span class="line">  ln -s /opt/mnt/node/bin/npm /usr/<span class="built_in">local</span>/bin/npm</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>至此node就安装成功了</code></pre><ol start="2">
<li><p>jenkins中配置nodejs</p>
<p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/1563848937513.png" alt="1563848937513"></p>
</li>
<li><p>全局安装相应的angular的框架</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli@7.3.9</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>修改npm的淘宝镜像，在/var/lib/jenkins的目录下创建相关</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo su -s /bin/bash jenkins <span class="comment">#登录jenkins</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/jenkins</span><br><span class="line">touch .npmrc</span><br><span class="line">vi .npmrc</span><br><span class="line">registry=https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="七，jenkins修改用户运行"><a href="#七，jenkins修改用户运行" class="headerlink" title="七，jenkins修改用户运行"></a>七，jenkins修改用户运行</h3><ol>
<li><p>解决登录jenkins的问题，由于jenkins在运行时可以选择用户进行运行；</p>
<ul>
<li><p>打开Jenkins配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br></pre></td></tr></table></figure>

<p>找到如下行：</p>
<p>将原来的Jenkins用户修改为root用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JENKINS_USER=&quot;root&quot;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
<ul>
<li><p>修改Jenkins相关文件夹用户权限</p>
<p>更改jenkins三个文件夹的用户所属用户组：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown -R root:root /var/lib/jenkins   jenkins的home目录</span><br><span class="line">chown -R root:root /var/cache/jenkins jenkins的缓存目录</span><br><span class="line">chown -R root:root /var/<span class="built_in">log</span>/jenkins   jenkins的日志目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启jenkins</p>
<p>重启jenkins服务并检查运行Jenkins的用户是否已经切换为root</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart jenkins</span><br><span class="line">ps -ef | grep jenkins</span><br></pre></td></tr></table></figure>

<p>若显示为root用户，则表示修改完成</p>
</li>
</ul>
<h3 id="八，报错解决"><a href="#八，报错解决" class="headerlink" title="八，报错解决"></a>八，报错解决</h3><ol>
<li><p>jenkins登录不了Harbor问题</p>
<p> 错误内容：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.34/version: dial unix /var/run/docker.sock: connect: permission denied</span><br></pre></td></tr></table></figure>

<p> 解决方案：</p>
<ul>
<li><p>优先参考官方<a href="https://docs.docker.com/engine/installation/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">Manage Docker as a non-root user</a></p>
</li>
<li><p>关闭虚拟机的selinux（可能有用）。参考<a href="http://blog.51cto.com/bguncle/957315" target="_blank" rel="noopener">查看 SELinux状态及关闭SELinux</a></p>
</li>
<li><p>在虚拟机中修改<code>/var/run/docker.sock</code>的权限。（很危险！！！）(不推荐)</p>
<p>终极解决方案：</p>
<p>错误原因是，在push之前，需要使用docker login命令完成登录</p>
<p>但是Jenkins job的命令是以伪用户jenkins的名义执行的，因此无法直接在jenkins账户完成登录，那么如何解决呢？</p>
</li>
<li><p>使用root账户完成登录</p>
</li>
<li><p>将/root/目录下的.docker目录复制到/var/lib/jenkins jenkins的家目录</p>
</li>
<li><p>修改文件夹权限chown -R jenkins:jenkins .docker</p>
<p>原理是：登录成功后会在.docker中生成一个config.json文件，里面保存了认证的信息，以后每次执行docker pull/push时，都会通过检测该文件确定用户是否已完成认证。</p>
<p><a href="https://blog.csdn.net/mydeman/article/details/79042848" target="_blank" rel="noopener">参考文档1</a></p>
<p><a href="https://my.oschina.net/raindroid/blog/1579639" target="_blank" rel="noopener">参考文档2</a></p>
</li>
</ul>
</li>
<li><p>切换jenkins用户登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -s /bin/bash jenkins</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li><p>解决jenkins拉取不了私服代码的问题<br><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/clipboard_20190723100820.png" alt="1563847680915"></p>
<ul>
<li><p>参考Jenkins在git SSH配置</p>
</li>
<li><p><a href="https://stackoverflow.com/questions/15174194/jenkins-host-key-verification-failed" target="_blank" rel="noopener">参考地址</a></p>
</li>
</ul>
</li>
<li><p>Jenkins远程连接linux</p>
<p> 由于配置原因造成一下错误</p>
<p> 错误：jenkins.plugins.publish_over.BapPublisherException: Failed to connect session for config [131]. Message [Auth fail]</p>
<p> 配置方法：</p>
<ul>
<li><p>生成密钥</p>
<p>在我的jenkins服务器上/var/lib/jenkins用户目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen <span class="comment"># 密钥生成路径直接默认回车</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys <span class="comment"># 将公钥拷贝到authorized_keys文件</span></span><br><span class="line">scp authorized_keys user@ip:/root/.ssh <span class="comment">#将生成的authorized_keys拷贝到要连接的linux机器上的对应用户下的.ssh文件夹下</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置SSH server  系统管理-&gt;系统设置</p>
<p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/590119-20170718153657958-1551906167.png" alt="系统设置"></p>
<p>点击测试</p>
<p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/jenkins/590119-20170718153902255-554801851.png" alt="test ssh"></p>
</li>
<li><p><a href="https://www.cnblogs.com/wangqianqiannb/p/7200791.html" target="_blank" rel="noopener">参考连接</a></p>
</li>
</ul>
</li>
</ol>
<h3 id="九，总结"><a href="#九，总结" class="headerlink" title="九，总结"></a>九，总结</h3><p>​        至此yum源安装的jenkins就完毕了，之后会陆续推出相关的docker中安装jenkins，在k8s中使用jenkins的master/salves模式</p>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/18/Harbor安装与配置/">Harbor安装与配置</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-18T00:26:33.000Z" itemprop="datePublished">2019-07-18</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/Docker/">Docker</a>, <a class="article-tag-link" href="/tags/Harbor/">Harbor</a>, <a class="article-tag-link" href="/tags/docker-compose/">docker-compose</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="企业级私有镜像仓库的使用"><a href="#企业级私有镜像仓库的使用" class="headerlink" title="企业级私有镜像仓库的使用"></a>企业级私有镜像仓库的使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​        Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源Docker Distribution。作为一个企业级私有Registry服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor支持安装在多个Registry节点的镜像资源复制，镜像全部保存在私有Registry中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。</p>
<ul>
<li><strong>基于角色的访问控制</strong>- 用户与Docker镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。</li>
<li><strong>镜像复制</strong> - 镜像可以在多个Registry实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。</li>
<li><strong>图形化用户界面</strong> - 用户可以通过浏览器来浏览，检索当前Docker镜像仓库，管理项目和命名空间。</li>
<li><strong>AD/LDAP 支持</strong> - Harbor可以集成企业内部已有的AD/LDAP，用于鉴权认证管理。</li>
<li><strong>审计管理</strong> - 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。<br>国际化 - 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。</li>
<li><strong>RESTful API</strong> - RESTful API 提供给管理员对于Harbor更多的操控, 使得与其它管理软件集成变得更容易。</li>
<li><strong>部署简单</strong> - 提供在线和离线两种安装工具， 也可以安装到vSphere平台(OVA方式)虚拟设备。</li>
</ul>
<h3 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h3><p>Harbor被部署为多个Docker容器，因此可以部署在任何支持Docker的Linux发行版上，目标主机需要Docker,并且要安装Docker Compose</p>
<ul>
<li><p>硬件</p>
<table>
<thead>
<tr>
<th>Resource</th>
<th>Capacity</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td>minimal 2 CPU</td>
<td>4 CPU is preferred</td>
</tr>
<tr>
<td>Mem</td>
<td>minimal 4GB</td>
<td>8GB is preferred</td>
</tr>
<tr>
<td>Disk</td>
<td>minimal 40GB</td>
<td>160GB is preferred</td>
</tr>
</tbody></table>
</li>
<li><p>软件</p>
<table>
<thead>
<tr>
<th>Software</th>
<th>Version</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Docker engine</td>
<td>version 17.06.0-ce+ or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">docker engine doc</a></td>
</tr>
<tr>
<td>Docker Compose</td>
<td>version 1.18.0 or higher</td>
<td>For installation instructions, please refer to: <a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">docker compose doc</a></td>
</tr>
<tr>
<td>Openssl</td>
<td>latest is preferred</td>
<td>Generate certificate and keys for Harbor</td>
</tr>
</tbody></table>
</li>
<li><p>网络端口</p>
<table>
<thead>
<tr>
<th>Port</th>
<th>Protocol</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>443</td>
<td>HTTPS</td>
<td>Harbor portal and core API will accept requests on this port for https protocol, this port can change in config file</td>
</tr>
<tr>
<td>4443</td>
<td>HTTPS</td>
<td>Connections to the Docker Content Trust service for Harbor, only needed when Notary is enabled, This port can change in config file</td>
</tr>
<tr>
<td>80</td>
<td>HTTP</td>
<td>Harbor portal and core API will accept requests on this port for http protocol</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Harbor安装"><a href="#Harbor安装" class="headerlink" title="Harbor安装"></a>Harbor安装</h3><p>Harbor在github上的<a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">地址</a>，从readme.md中可以知道安装的<a href="https://github.com/vmware/harbor/blob/master/docs/installation_guide.md" target="_blank" rel="noopener">方式</a>分为</p>
<ul>
<li><strong>Online installer</strong>（这是harbor的一种安装方式，与本文标题线上搭建无关联）</li>
<li><strong>Offline installer</strong>（本文主讲）</li>
<li><strong>OVA installer</strong></li>
</ul>
<p>至于Online installer和OVA installer这两种搭建方式，本文不会提及，有兴趣的同学可以自己尝试，相信在看完本文之后你也可以完成自己的Harbor仓库的搭建。</p>
<h4 id="Offline-installer"><a href="#Offline-installer" class="headerlink" title="Offline installer"></a>Offline installer</h4><p>在官方的<a href="https://github.com/vmware/harbor/releases" target="_blank" rel="noopener">发布版本</a>中,找到一个最新的发布版本（本文写与2019.07.18，官方version为1.8.1）</p>
<p>下载之后会得到一个类似于harbor-offline-installer-v1.8.1.tgz的文件，用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v1.8.1.tgz</span><br></pre></td></tr></table></figure>

<h5 id="Harbor目录简介"><a href="#Harbor目录简介" class="headerlink" title="Harbor目录简介"></a>Harbor目录简介</h5><ul>
<li>harbor.v1.8.1.tar.gz</li>
<li>harbor.yml 启动harbor时使用的配置文件</li>
<li>install.sh 是一个shell脚本启动脚本</li>
<li>LICENSE 该版本许可信息</li>
<li>prepare python写的初始化脚本</li>
</ul>
<h5 id="http安装方式"><a href="#http安装方式" class="headerlink" title="http安装方式"></a>http安装方式</h5><p>安装步骤</p>
<ul>
<li><p>配置好harbor.yml</p>
<p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/1563438641.jpg" alt="1563438641"></p>
</li>
<li><p>运行install.sh 或者(./prepare 再使用docker-compose up -d启动)</p>
</li>
<li><p>使用浏览器<a href="http://ip可以访问harbor的web页面" target="_blank" rel="noopener">http://ip可以访问harbor的web页面</a></p>
</li>
<li><p>其他docker客户端如何推送到该私有镜像仓库呢？</p>
<ul>
<li><p>Harbor的默认安装使用<em>HTTP</em> - 因此，您需要将该选项添加<code>--insecure-registry</code>到客户端的Docker守护程序并重新启动Docker服务。</p>
</li>
<li><p>在客户端的docker服务器中的/etc/docker/daemon.josn中配置</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"insecure-registry"</span>:<span class="string">"harbor服务器的ip"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<ul>
<li><p>登录 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login ip -u admin -p Harbor12345</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="https安装方式"><a href="#https安装方式" class="headerlink" title="https安装方式"></a>https安装方式</h5><ul>
<li><p>首先也是配置harbor.yml文件(放开https配置，配置相应的域名)</p>
</li>
<li><p>根据<a href="https://github.com/goharbor/harbor/blob/master/docs/configure_https.md" target="_blank" rel="noopener">官方</a>的文档生成对应的ssl密钥文件</p>
</li>
<li><p><img src="https://huangjie-1256186459.cos.ap-shanghai.myqcloud.com/blog/1563439550.jpg" alt="1563439550"></p>
</li>
<li><p>在对应的dockers客户端的/etc/hosts添加相应的域名解析</p>
</li>
<li><p>运行install.sh 或者(./prepare 再使用docker-compose up -d启动)</p>
</li>
<li><p>在电脑上配置 C:\Windows\System32\drivers\etc\hosts增加相应的域名解析，使用浏览器在<a href="https://ip可以访问harbor的web页面" target="_blank" rel="noopener">https://ip可以访问harbor的web页面</a></p>
</li>
<li><p>登录</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login 域名 -u admin -p Harbor12345</span><br></pre></td></tr></table></figure></li>
</ul>

        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/12/微服务使用场景分析/">微服务使用场景分析</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-12T06:33:25.000Z" itemprop="datePublished">2019-07-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/java/">java</a>, <a class="article-tag-link" href="/tags/微服务/">微服务</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="微服务是什么"><a href="#微服务是什么" class="headerlink" title="微服务是什么"></a>微服务是什么</h2><h2 id="微服务能带来什么好处"><a href="#微服务能带来什么好处" class="headerlink" title="微服务能带来什么好处"></a>微服务能带来什么好处</h2><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2>
        
    </section>
</article>


    <article class="article" itemscope itemprop="blogPost">
    
    <header class="article-header">
        
        <h1 itemprop="name">
            <a href="/2019/07/12/jenkins-gogs-harbor-docker自动化环境部署与安装/">jenkins+gogs+harbor+docker自动化环境部署与安装</a>
        </h1>
        
        <div class="article-meta clearfix">
            <a class="article-date" href="https://hj0913.github.io/index.html">
    
    <i class="icon-calendar"></i>
    
    <time datetime="2019-07-12T02:46:29.000Z" itemprop="datePublished">2019-07-12</time>
</a>

            
<div class="article-tag-list">
    <i class="icon-tag"></i>
    <a class="article-tag-link" href="/tags/docker/">docker</a>, <a class="article-tag-link" href="/tags/gogs/">gogs</a>, <a class="article-tag-link" href="/tags/harbor/">harbor</a>, <a class="article-tag-link" href="/tags/java/">java</a>, <a class="article-tag-link" href="/tags/jenkins/">jenkins</a>
</div>


        </div>
    </header>
    
    <section class="article-body markdown-body">
        
        <h2 id="一，docker环境安装"><a href="#一，docker环境安装" class="headerlink" title="一，docker环境安装"></a>一，docker环境安装</h2><p>docker 环境的安装在官网上由相关的安装文档，将其写成ansible的脚本的形式</p>
<h2 id="二，gogs安装"><a href="#二，gogs安装" class="headerlink" title="二，gogs安装"></a>二，gogs安装</h2><h2 id="三，harbor安装"><a href="#三，harbor安装" class="headerlink" title="三，harbor安装"></a>三，harbor安装</h2><h2 id="四，jenkins安装"><a href="#四，jenkins安装" class="headerlink" title="四，jenkins安装"></a>四，jenkins安装</h2><h2 id="五，打包部署应用"><a href="#五，打包部署应用" class="headerlink" title="五，打包部署应用"></a>五，打包部署应用</h2>
        
    </section>
</article>




<nav class="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
</nav>


</div>
        <footer class="footer">
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a>

    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?e4027971a230b210f4671f485b33846a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
    
</footer>

    </main>

    <script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script>
    <script type="text/javascript">
    $(function() {
        var nodes = {
            nav: $('#nav'),
            aside: $('#aside'),
            asideInner: $('#aside-inner'),
            navInner: $('#nav-inner')
        };

        var doing = false;
        nodes.asideInner.on('webkitAnimationEnd mozAnimationEnd oAnimationEnd oanimationend animationend', function() {
            if (nodes.aside.hasClass('mobile-open')) {
                nodes.aside.removeClass('mobile-open');
            } else {
                nodes.aside.removeClass('mobile-close panel-show');
            }
            doing = false;
        });
        $('#open-panel, #aside-mask').on('click', function() {
            if (doing) {
                return;
            }
            
            if (nodes.aside.hasClass('panel-show')) {
                nodes.aside.addClass('mobile-close');
            } else {
                nodes.aside.addClass('mobile-open panel-show');
            }
        });
        $('#open-menus').on('click', function() {
            nodes.navInner.slideToggle();
        });

        if (window.innerWidth <= 960) {
            setTimeout(function() {
                nodes.navInner.slideUp();
            }, 3000);
        }
    });
    </script>
    

</body>
</html>
